{
  "version": 3,
  "sources": ["../../cache-parser/src/internal.ts", "../../cache-parser/src/util.ts", "../../cache-parser/src/parse.ts", "../../cache-parser/src/tokenize.ts", "../../cache-parser/src/index.ts", "../../fast-defer/src/internal.ts", "../../fast-defer/src/create-deferred.ts", "../../fast-defer/src/is-deferred.ts", "../../object-code/src/util.ts", "../../object-code/src/hash.ts", "../../axios-cache-interceptor/src/header/headers.ts", "../../axios-cache-interceptor/src/header/interpreter.ts", "../../axios-cache-interceptor/src/util/cache-predicate.ts", "../../axios-cache-interceptor/src/interceptors/util.ts", "../../axios-cache-interceptor/src/interceptors/request.ts", "../../axios-cache-interceptor/src/util/update-cache.ts", "../../axios-cache-interceptor/src/interceptors/response.ts", "../../axios-cache-interceptor/src/storage/build.ts", "../../axios-cache-interceptor/src/storage/memory.ts", "../../axios-cache-interceptor/src/util/key-generator.ts", "../../axios-cache-interceptor/src/cache/create.ts", "../../axios-cache-interceptor/src/storage/web-api.ts"],
  "sourcesContent": ["/** @internal */\nexport const cacheControlSymbol = Symbol('cache-parser');\n", "export function isDuration(val: unknown): boolean {\n  return (\n    (typeof val === 'string' || typeof val === 'number') &&\n    (val = Number(val)) >= 0 &&\n    (val as number) < Infinity\n  );\n}\n\nexport function isTruthy(val: unknown): boolean {\n  return (\n    val === true ||\n    typeof val === 'number' ||\n    (typeof val === 'string' && val !== 'false')\n  );\n}\n\nexport function parseRawHeaders(headerStr: string): Record<string, string | true> {\n  const headers: Record<string, string | true> = {};\n  const tokens = headerStr.toLowerCase().replace(/\\s+/g, '').split(',');\n\n  for (const token of tokens) {\n    const split = token.split('=', 2) as [string, string];\n    headers[split[0]] = split[1] ?? true;\n  }\n\n  return headers;\n}\n", "import type { CacheControl } from './index';\nimport { cacheControlSymbol } from './internal';\nimport { isDuration, isTruthy, parseRawHeaders } from './util';\n\nconst number = Number;\n\n/**\n * Parses the Cache-Control header.\n *\n * You can check if a object was returned by this function with {@link isCacheControl} .\n *\n * @param {string} Header The header to parse\n * @returns {CacheControl} The parsed cache control header\n */\nexport function parse(headerStr?: string): CacheControl {\n  const header: CacheControl = Object.defineProperty({}, cacheControlSymbol, {\n    enumerable: false,\n    value: 1\n  });\n\n  if (!headerStr || typeof headerStr !== 'string') {\n    return header;\n  }\n\n  const headers = parseRawHeaders(headerStr);\n\n  const maxAge = headers['max-age'];\n  const maxStale = headers['max-stale'];\n  const minFresh = headers['min-fresh'];\n  const sMaxAge = headers['s-maxage'];\n  const staleIfError = headers['stale-if-error'];\n  const staleWhileRevalidate = headers['stale-while-revalidate'];\n\n  if (isTruthy(headers['immutable'])) {\n    header.immutable = true;\n  }\n\n  if (isDuration(maxAge)) {\n    header.maxAge = number(maxAge);\n  }\n\n  if (isDuration(maxStale)) {\n    header.maxStale = number(maxStale);\n  }\n\n  if (isDuration(minFresh)) {\n    header.minFresh = number(minFresh);\n  }\n\n  if (isTruthy(headers['must-revalidate'])) {\n    header.mustRevalidate = true;\n  }\n\n  if (isTruthy(headers['must-understand'])) {\n    header.mustUnderstand = true;\n  }\n\n  if (isTruthy(headers['no-cache'])) {\n    header.noCache = true;\n  }\n\n  if (isTruthy(headers['no-store'])) {\n    header.noStore = true;\n  }\n\n  if (isTruthy(headers['no-transform'])) {\n    header.noTransform = true;\n  }\n\n  if (isTruthy(headers['only-if-cached'])) {\n    header.onlyIfCached = true;\n  }\n\n  if (isTruthy(headers['private'])) {\n    header.private = true;\n  }\n\n  if (isTruthy(headers['proxy-revalidate'])) {\n    header.proxyRevalidate = true;\n  }\n\n  if (isTruthy(headers['public'])) {\n    header.public = true;\n  }\n\n  if (isDuration(sMaxAge)) {\n    header.sMaxAge = number(sMaxAge);\n  }\n\n  if (isDuration(staleIfError)) {\n    header.staleIfError = number(staleIfError);\n  }\n\n  if (isDuration(staleWhileRevalidate)) {\n    header.staleWhileRevalidate = number(staleWhileRevalidate);\n  }\n\n  return header;\n}\n", "/* eslint-disable @typescript-eslint/restrict-template-expressions */\nimport type { CacheControl } from './index';\nimport { isDuration, isTruthy } from './util';\n\n/**\n * Return an array of tokens from the header object.\n *\n * #### The output is sorted by alphabetical order\n *\n * The cache control object does not need to be a CacheControl object from the\n * {@link CacheControl}.This means that the parameter do not have to pass in the\n * {@link isCacheControl} function.\n *\n * You can build a string with `.join(', ')` method.\n *\n * @example\n *\n * ```js\n * const tokens = tokenize({ maxAge: 3600, noCache: true }); // ['max-age=3600',\n * 'no-cache']\n *\n * const header = tokens.join(', '); // 'max-age=3600, no-cache'\n * ```\n *\n * @param header The cache control object\n * @returns An array of directives an their respective values.\n */\nexport function tokenize(header?: CacheControl): string[] {\n  if (!header || typeof header !== 'object') {\n    return [];\n  }\n\n  const tokens: string[] = [];\n\n  if (isTruthy(header.immutable)) {\n    tokens.push('immutable');\n  }\n\n  if (isDuration(header.maxAge)) {\n    tokens.push(`max-age=${header.maxAge}`);\n  }\n\n  if (isDuration(header.maxStale)) {\n    tokens.push(`max-stale=${header.maxStale}`);\n  }\n\n  if (isDuration(header.minFresh)) {\n    tokens.push(`min-fresh=${header.minFresh}`);\n  }\n\n  if (isTruthy(header.mustRevalidate)) {\n    tokens.push('must-revalidate');\n  }\n\n  if (isTruthy(header.mustUnderstand)) {\n    tokens.push('must-understand');\n  }\n\n  if (isTruthy(header.noCache)) {\n    tokens.push('no-cache');\n  }\n\n  if (isTruthy(header.noStore)) {\n    tokens.push('no-store');\n  }\n\n  if (isTruthy(header.noTransform)) {\n    tokens.push('no-transform');\n  }\n\n  if (isTruthy(header.onlyIfCached)) {\n    tokens.push('only-if-cached');\n  }\n\n  if (isTruthy(header.private)) {\n    tokens.push('private');\n  }\n\n  if (isTruthy(header.proxyRevalidate)) {\n    tokens.push('proxy-revalidate');\n  }\n\n  if (isTruthy(header.public)) {\n    tokens.push('public');\n  }\n\n  if (isDuration(header.sMaxAge)) {\n    tokens.push(`s-maxage=${header.sMaxAge}`);\n  }\n\n  if (isDuration(header.staleIfError)) {\n    tokens.push(`stale-if-error=${header.staleIfError}`);\n  }\n\n  if (isDuration(header.staleWhileRevalidate)) {\n    tokens.push(`stale-while-revalidate=${header.staleWhileRevalidate}`);\n  }\n\n  return tokens;\n}\n", "/* eslint-disable @typescript-eslint/no-unsafe-member-access */\nimport { cacheControlSymbol } from './internal';\n\nexport * from './parse';\nexport * from './tokenize';\n\n/**\n * Detects if the given parameter is a {@link CacheControl} object.\n *\n * @param {any} obj The object to test\n * @returns {boolean} True if the parameter was created by the {@link parse} function\n */\nexport function isCacheControl(obj?: unknown): obj is CacheControl {\n  return !!obj && !!(obj as Record<symbol, boolean>)[cacheControlSymbol];\n}\n\n/**\n * The Cache-Control HTTP header field holds directives (instructions) — in both requests\n * and responses — that control caching in browsers and shared caches (e.g. Proxies,\n * CDNs).\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\n */\nexport declare type CacheControl = {\n  /**\n   * The immutable response directive indicates that the response will not be updated\n   * while it's fresh.\n   *\n   * ```txt\n   * Cache-Control: public, max-age=604800, immutable\n   * ```\n   *\n   * A modern best practice for static resources is to include version/hashes in their\n   * URLs, while never modifying the resources — but instead, when necessary, updating the\n   * resources with newer versions that have new version-numbers/hashes, so that their\n   * URLs are different. That’s called the cache-busting pattern.\n   *\n   * ```html\n   * <script src=https://example.com/react.0.0.0.js></script>\n   * ```\n   *\n   * When a user reloads the browser, the browser will send conditional requests for\n   * validating to the origin server. But it's not necessary to revalidate those kinds of\n   * static resources even when a user reloads the browser, because they're never\n   * modified. immutable tells a cache that the response is immutable while it's fresh,\n   * and avoids those kinds of unnecessary conditional requests to the server.\n   *\n   * When you use a cache-busting pattern for resources and apply them to a long max-age,\n   * you can also add immutable to avoid revalidation.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#immutable\n   */\n  immutable?: true;\n  /**\n   * The max-age=N response directive indicates that the response remains fresh until N\n   * seconds after the response is generated.\n   *\n   * ```txt\n   * Cache-Control: max-age=604800\n   * ```\n   *\n   * Indicates that caches can store this response and reuse it for subsequent requests\n   * while it's fresh.\n   *\n   * Note that max-age is not the elapsed time since the response was received, but\n   * instead the elapsed time since the response was generated on the origin server. So if\n   * the other cache(s) on the path the response takes store it for 100 seconds (indicated\n   * using the Age response header field), the browser cache would deduct 100 seconds from\n   * its freshness lifetime.\n   *\n   * ```txt\n   * Cache-Control: max-age=604800\n   * Age: 100\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#max-age\n   */\n  maxAge?: number;\n  /**\n   * The max-stale=N request directive indicates that the client allows a stored response\n   * that is stale within N seconds.\n   *\n   * ```txt\n   * Cache-Control: max-stale=3600\n   * ```\n   *\n   * In the case above, if the response with Cache-Control: max-age=604800 was stored on\n   * caches 3 hours ago, the cache couldn't reuse that response.\n   *\n   * Clients can use this header when the origin server is down or too slow and can accept\n   * cached responses from caches even if they are a bit old.\n   *\n   * Note that the major browsers do not support requests with max-stale.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#max-stale\n   */\n  maxStale?: number;\n  /**\n   * The min-fresh=N request directive indicates that the client allows a stored response\n   * that is fresh for at least N seconds.\n   *\n   * ```txt\n   * Cache-Control: min-fresh=600\n   * ```\n   *\n   * In the case above, if the response with Cache-Control: max-age=3600 was stored in\n   * caches 51 minutes ago, the cache couldn't reuse that response.\n   *\n   * Clients can use this header when the user requires the response to not only be fresh,\n   * but also requires that it won't be updated for a period of time.\n   *\n   * Note that the major browsers do not support requests with min-fresh.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#min-fresh\n   */\n  minFresh?: number;\n  /**\n   * The must-revalidate response directive indicates that the response can be stored in\n   * caches and can be reused while fresh. Once it becomes stale, it must be validated\n   * with the origin server before reuse.\n   *\n   * Typically, must-revalidate is used with max-age.\n   *\n   * ```txt\n   * Cache-Control: max-age=604800, must-revalidate\n   * ```\n   *\n   * HTTP allows caches to reuse stale responses when they are disconnected from the\n   * origin server. must-revalidate is a way to prevent that, so that the cache either\n   * revalidates the stored response with the origin server, or if that's not possible it\n   * generates a 504 (Gateway Timeout) response.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#must-revalidate\n   */\n  mustRevalidate?: true;\n\n  mustUnderstand?: true;\n  /**\n   * The no-cache response directive indicates that the response can be stored in caches,\n   * but must be validated with the origin server before each reuse — even when the cache\n   * is disconnected from the origin server.\n   *\n   * ```txt\n   * Cache-Control: no-cache\n   * ```\n   *\n   * If you want caches to always check for content updates while reusing stored content\n   * when it hasn't changed, no-cache is the directive to use. It does this by requiring\n   * caches to revalidate each request with the origin server.\n   *\n   * Note that no-cache does not mean \"don't cache\". no-cache allows caches to store a\n   * response, but requires them to revalidate it before reuse. If the sense of \"don't\n   * cache\" that you want is actually \"don't store\", then no-store is the directive to\n   * use.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#no-cache\n   */\n  noCache?: true;\n  /**\n   * The no-store response directive indicates that any caches of any kind (private or\n   * shared) should not store this response.\n   *\n   * ```txt\n   * Cache-Control: no-store\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#no-store\n   */\n  noStore?: true;\n  /**\n   * Some intermediaries transform content for various reasons. For example, some convert\n   * images to reduce transfer size. In some cases, this is undesirable for the content\n   * provider.\n   *\n   * No-transform indicates that any intermediary (regardless of whether it implements a\n   * cache) shouldn't transform the response contents.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#no-transform\n   */\n  noTransform?: true;\n  /**\n   * The client indicates that cache should obtain an already-cached response. If a cache\n   * has stored a response, it’s reused.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#only-if-cached\n   */\n  onlyIfCached?: true;\n  /**\n   * The private response directive indicates that the response can be stored only in a\n   * private cache (e.g. local caches in browsers).\n   *\n   * ```txt\n   * Cache-Control: private\n   * ```\n   *\n   * You should add the private directive for user-personalized content — in particular,\n   * responses received after login, and sessions managed via cookies.\n   *\n   * If you forget to add private to a response with personalized content, then that\n   * response can be stored in a shared cache and end up being used by multiple users,\n   * which can cause personal information to leak.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#private\n   */\n  private?: true;\n  /**\n   * The proxy-revalidate response directive is the equivalent of must-revalidate, but\n   * specifically for shared caches only.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#proxy-revalidate\n   */\n  proxyRevalidate?: true;\n  /**\n   * Responses for requests with Authorization header fields must not be stored in a\n   * shared cache. But the public directive will cause such responses to be stored in a\n   * shared cache.\n   *\n   * ```txt\n   * Cache-Control: public\n   * ```\n   *\n   * In general, when pages are under Basic Auth or Digest Auth, the browser sends\n   * requests with the Authorization header. That means the response is access-controlled\n   * for restricted users (who have accounts), and it's fundamentally not\n   * shared-cacheable, even if it has max-age.\n   *\n   * You can use the public directive to unlock that restriction.\n   *\n   * ```txt\n   * Cache-Control: public, max-age=604800\n   * ```\n   *\n   * Note that, s-maxage or must-revalidate also unlock that restriction.\n   *\n   * If a request doesn’t have an Authorization header, or you are already using s-maxage\n   * or must-revalidate in the response, then you don't need to use public.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#public\n   */\n  public?: true;\n  /**\n   * The s-maxage response directive also indicates how long the response is fresh for\n   * (similar to max-age) — but it is specific to shared caches, and they will ignore\n   * max-age when it is present.\n   *\n   * ```txt\n   * Cache-Control: s-maxage=604800\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage\n   */\n  sMaxAge?: number;\n  /**\n   * The stale-if-error response directive indicates that the cache can reuse a stale\n   * response when an origin server responds with an error (500, 502, 503, or 504).\n   *\n   * ```txt\n   * Cache-Control: max-age=604800, stale-if-error=86400\n   * ```\n   *\n   * In the example above, the response is fresh for 7 days (604800s). After 7 days it\n   * becomes stale, but it can be used for an extra 1 day (86400s) if the server responds\n   * with an error.\n   *\n   * After a period of time, the stored response became stale normally. That means the\n   * client will receive an error response as-is if the origin server sends it.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error\n   */\n  staleIfError?: number;\n  /**\n   * The stale-while-revalidate response directive indicates that the cache could reuse a\n   * stale response while it revalidates it to a cache.\n   *\n   * ```txt\n   * Cache-Control: max-age=604800, stale-while-revalidate=86400\n   * ```\n   *\n   * In the example above, the response is fresh for 7 days (604800s). After 7 days, it\n   * becomes stale but the cache is allowed to reuse it for any requests that are made in\n   * the following day (86400s) — provided that they revalidate the response in the\n   * background.\n   *\n   * Revalidation will make the cache be fresh again, so it appears to clients that it was\n   * always fresh during that period — effectively hiding the latency penalty of\n   * revalidation from them.\n   *\n   * If no request happened during that period, the cache became stale and the next\n   * request will revalidate normally.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate\n   */\n  staleWhileRevalidate?: number;\n};\n", "/** @internal */\nexport const fastDeferSymbol = Symbol();\n", "import type { Deferred } from './deferred';\nimport { fastDeferSymbol } from './internal';\n\n/** @returns A new {@link Deferred} object */\nexport function deferred<T>() {\n  let resolve!: Deferred<T>['resolve'];\n  let reject!: Deferred<T>['reject'];\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  }) as Deferred<T>;\n\n  promise.resolve = resolve;\n  promise.reject = reject;\n  promise[fastDeferSymbol] = 1;\n\n  return promise;\n}\n", "import type { Deferred } from './deferred';\nimport { fastDeferSymbol } from './internal';\n\n/**\n * Detects if the given parameter is a {@link Deferred}\n *\n * @param {any} value The promise to validate\n * @returns True if the given promise is a deferred, false otherwise\n */\nexport function isDeferred(value?: unknown): value is Deferred {\n  return !!value && !!(value as Deferred)[fastDeferSymbol];\n}\n", "export function sortNumbers(a: string, b: string) {\n  return a > b ? 1 : -1;\n}\n", "import { sortNumbers } from './util';\n\n/**\n * Hashes a given value into a unique number.\n *\n * This function accepts **ANY** kind of value, like `functions`, `classes`, `objects` and\n * so on.\n *\n * **Note**: Symbols uniqueness are not guaranteed, as they are transformed to strings.\n *\n * @example\n *\n * ```ts\n * class B {}\n *\n * const bHash = hash(B);\n * const bInstanceHash = hash(new B());\n * const bArrayHash = hash([B, new B(), new B(), { b: new B() }]);\n * const bBuilderHash = hash(() => B);\n * const bFactoryHash = hash(() => new B());\n * ```\n *\n * @param val The value to be hashed\n * @returns The signed integer result from the provided value\n * @see https://tinylibs.js.org/packages/object-code/\n */\nexport function hash(val: unknown, seen?: WeakSet<object>): number {\n  let h = 5381;\n\n  // Objects should be recursively hashed\n  if (\n    typeof val === 'object' &&\n    val !== null &&\n    (val.toString === Object.prototype.toString ||\n      val.toString === Array.prototype.toString)\n  ) {\n    if (!seen) {\n      seen = new WeakSet();\n    }\n\n    // Sort keys to keep the hash consistent\n    const keys = Object.keys(val).sort(sortNumbers);\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const value = val[key as keyof typeof val] as object;\n\n      h = (h * 33) ^ hash(key, seen);\n\n      // Uses an internal WeakMap to keep track of previous seen values\n      // and avoid circular references serializations which would cause\n      // an infinite loop.\n      if (\n        typeof value === 'object' &&\n        value !== null &&\n        (val.toString === Object.prototype.toString ||\n          val.toString === Array.prototype.toString)\n      ) {\n        if (seen.has(value)) {\n          continue;\n        }\n\n        seen.add(value);\n      }\n\n      // Hashes the value\n      h = (h * 33) ^ hash(value, seen);\n    }\n\n    // Also hashes the constructor\n    h = (h * 33) ^ hash(val.constructor, seen);\n\n    return h;\n  }\n\n  let toHash = typeof val;\n\n  try {\n    if (val instanceof Date) {\n      toHash += val.getTime();\n    } else {\n      toHash += String(val);\n    }\n  } catch (error) {\n    toHash += String(Object.assign({}, val));\n  }\n\n  for (let i = 0; i < toHash.length; i++) {\n    h = (h * 33) ^ toHash.charCodeAt(i);\n  }\n\n  return h;\n}\n", "export const Header = Object.freeze({\n  /**\n   * ```txt\n   * If-Modified-Since: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since\n   */\n  IfModifiedSince: 'if-modified-since',\n\n  /**\n   * ```txt\n   * Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified\n   */\n  LastModified: 'last-modified',\n\n  /**\n   * ```txt\n   * If-None-Match: \"<etag_value>\"\n   * If-None-Match: \"<etag_value>\", \"<etag_value>\", …\n   * If-None-Match: *\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match\n   */\n  IfNoneMatch: 'if-none-match',\n\n  /**\n   * ```txt\n   * Cache-Control: max-age=604800\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\n   */\n  CacheControl: 'cache-control',\n\n  /**\n   * ```txt\n   * Pragma: no - cache;\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Pragma\n   */\n  Pragma: 'pragma',\n\n  /**\n   * ```txt\n   * ETag: W / '<etag_value>';\n   * ETag: '<etag_value>';\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag\n   */\n  ETag: 'etag',\n\n  /**\n   * ```txt\n   * Expires: <http-date>\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires\n   */\n  Expires: 'expires',\n\n  /**\n   * ```txt\n   * Age: <delta-seconds>\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age\n   */\n  Age: 'age',\n\n  /**\n   * Used internally as metadata to mark the cache item as revalidatable and enabling\n   * stale cache state Contains a string of ASCII characters that can be used as ETag for\n   * `If-Match` header Provided by user using `cache.etag` value.\n   *\n   * ```txt\n   * X-Axios-Cache-Etag: \"<etag_value>\"\n   * ```\n   */\n  XAxiosCacheEtag: 'x-axios-cache-etag',\n\n  /**\n   * Used internally as metadata to mark the cache item as revalidatable and enabling\n   * stale cache state may contain `'use-cache-timestamp'` if `cache.modifiedSince` is\n   * `true`, otherwise will contain a date from `cache.modifiedSince`. If a date is\n   * provided, it can be used for `If-Modified-Since` header, otherwise the cache\n   * timestamp can be used for `If-Modified-Since` header.\n   *\n   * ```txt\n   * X-Axios-Cache-Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n   * X-Axios-Cache-Last-Modified: use-cache-timestamp\n   * ```\n   */\n  XAxiosCacheLastModified: 'x-axios-cache-last-modified',\n\n  /**\n   * Used internally as metadata to mark the cache item able to be used if the server\n   * returns an error. The stale-if-error response directive indicates that the cache can\n   * reuse a stale response when any error occurs.\n   *\n   * ```txt\n   * XAxiosCacheStaleIfError: <seconds>\n   * ```\n   */\n  XAxiosCacheStaleIfError: 'x-axios-cache-stale-if-error'\n});\n", "import { parse } from 'cache-parser';\nimport { Header } from './headers.js';\nimport type { HeaderInterpreter } from './types.js';\n\nexport const defaultHeaderInterpreter: HeaderInterpreter = (headers, location) => {\n  if (!headers) return 'not enough headers';\n\n  const cacheControl: unknown = headers[Header.CacheControl];\n\n  if (cacheControl) {\n    const cc = parse(String(cacheControl));\n\n    if (\n      // Header told that this response should not be cached.\n      cc.noCache ||\n      cc.noStore ||\n      // Server side handling private data\n      (location === 'server' && cc.private)\n    ) {\n      return 'dont cache';\n    }\n\n    if (cc.immutable) {\n      // 1 year is sufficient, as Infinity may cause problems with certain storages.\n      // It might not be the best way, but a year is better than none. Facebook shows\n      // that a browser session stays at the most 1 month.\n      return {\n        cache: 1000 * 60 * 60 * 24 * 365\n      };\n    }\n\n    if (cc.maxAge !== undefined) {\n      const age: unknown = headers[Header.Age];\n\n      return {\n        cache: age\n          ? // If age is present, we must subtract it from maxAge\n            (cc.maxAge - Number(age)) * 1000\n          : cc.maxAge * 1000,\n        // Already out of date, must be requested again\n        stale:\n          // I couldn't find any documentation about who should be used, as they\n          // are not meant to overlap each other. But, as we cannot request in the\n          // background, as the stale-while-revalidate says, and we just increase\n          // its staleTtl when its present, max-stale is being preferred over\n          // stale-while-revalidate.\n          cc.maxStale !== undefined\n            ? cc.maxStale * 1000\n            : cc.staleWhileRevalidate !== undefined\n              ? cc.staleWhileRevalidate * 1000\n              : undefined\n      };\n    }\n  }\n\n  const expires: unknown = headers[Header.Expires];\n\n  if (expires) {\n    const milliseconds = Date.parse(String(expires)) - Date.now();\n    return milliseconds >= 0 ? { cache: milliseconds } : 'dont cache';\n  }\n\n  return 'not enough headers';\n};\n", "import type { CacheAxiosResponse } from '../cache/axios.js';\n\nimport type { CachePredicate, CachePredicateObject } from './types.js';\n\n/** Tests an response against a {@link CachePredicateObject}. */\nexport async function testCachePredicate<R = unknown, D = unknown>(\n  response: CacheAxiosResponse<R, D>,\n  predicate: CachePredicate<R, D>\n): Promise<boolean> {\n  if (typeof predicate === 'function') {\n    return predicate(response);\n  }\n\n  const { statusCheck, responseMatch, containsHeaders } = predicate;\n\n  if (\n    (statusCheck && !(await statusCheck(response.status))) ||\n    (responseMatch && !(await responseMatch(response)))\n  ) {\n    return false;\n  }\n\n  if (containsHeaders) {\n    for (const [header, predicate] of Object.entries(containsHeaders)) {\n      if (\n        !(await predicate(\n          // Avoid bugs in case the header is not in lower case\n          response.headers[header.toLowerCase()] ?? response.headers[header]\n        ))\n      ) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Determines whether a given URL matches a specified pattern, which can be either a string or a regular expression.\n *\n * @param matchPattern - The pattern to match against\n *   - If it's a regular expression, it will be reset to ensure consistent behavior for stateful regular expressions.\n *   - If it's a string, the function checks if the URL contains the string.\n * @param configUrl - The URL to test against the provided pattern; normally `config.url`.\n * @returns `true` if the `configUrl` matches the `matchPattern`\n */\nexport function regexOrStringMatch(matchPattern: string | RegExp, configUrl: string) {\n  if (matchPattern instanceof RegExp) {\n    matchPattern.lastIndex = 0; // Reset the regex to ensure consistent matching\n    return matchPattern.test(configUrl);\n  }\n\n  return configUrl.includes(matchPattern);\n}\n", "import type { Method } from 'axios';\nimport type { CacheAxiosResponse, CacheRequestConfig } from '../cache/axios.js';\nimport type { CacheProperties } from '../cache/cache.js';\nimport { Header } from '../header/headers.js';\nimport type {\n  CachedResponse,\n  MustRevalidateStorageValue,\n  StaleStorageValue\n} from '../storage/types.js';\n\n/**\n * Creates a new validateStatus function that will use the one already used and also\n * accept status code 304.\n */\nexport function createValidateStatus(\n  oldValidate?: CacheRequestConfig['validateStatus']\n): (status: number) => boolean {\n  return oldValidate\n    ? (status) => oldValidate(status) || status === 304\n    : (status) => (status >= 200 && status < 300) || status === 304;\n}\n\n/** Checks if the given method is in the methods array */\nexport function isMethodIn(\n  requestMethod: Method | string = 'get',\n  methodList: Method[] = []\n): boolean {\n  requestMethod = requestMethod.toLowerCase() as Lowercase<Method>;\n  return methodList.some((method) => method === requestMethod);\n}\n\nexport interface ConfigWithCache<D> extends CacheRequestConfig<unknown, D> {\n  cache: Partial<CacheProperties<unknown, D>>;\n}\n\n/**\n * This function updates the cache when the request is stale. So, the next request to the\n * server will be made with proper header / settings.\n */\nexport function updateStaleRequest<D>(\n  cache: StaleStorageValue | MustRevalidateStorageValue,\n  config: ConfigWithCache<D>\n): void {\n  config.headers ||= {};\n\n  const { etag, modifiedSince } = config.cache;\n\n  if (etag) {\n    const etagValue = etag === true ? (cache.data?.headers[Header.ETag] as unknown) : etag;\n\n    if (etagValue) {\n      config.headers[Header.IfNoneMatch] = etagValue;\n    }\n  }\n\n  if (modifiedSince) {\n    config.headers[Header.IfModifiedSince] =\n      modifiedSince === true\n        ? // If last-modified is not present, use the createdAt timestamp\n          (cache.data.headers[Header.LastModified] as unknown) ||\n          new Date(cache.createdAt).toUTCString()\n        : modifiedSince.toUTCString();\n  }\n}\n\n/**\n * Creates the new date to the cache by the provided response. Also handles possible 304\n * Not Modified by updating response properties.\n */\nexport function createCacheResponse<R, D>(\n  response: CacheAxiosResponse<R, D>,\n  previousCache?: CachedResponse\n): CachedResponse {\n  if (response.status === 304 && previousCache) {\n    // Set the cache information into the response object\n    response.cached = true;\n    response.data = previousCache.data as R;\n    response.status = previousCache.status;\n    response.statusText = previousCache.statusText;\n\n    // Update possible new headers\n    response.headers = {\n      ...previousCache.headers,\n      ...response.headers\n    };\n\n    // return the old cache\n    return previousCache;\n  }\n\n  // New Response\n  return {\n    data: response.data,\n    status: response.status,\n    statusText: response.statusText,\n    headers: response.headers\n  };\n}\n", "import { deferred } from 'fast-defer';\nimport type { AxiosCacheInstance, CacheAxiosResponse } from '../cache/axios.js';\nimport { Header } from '../header/headers.js';\nimport type { CachedResponse, CachedStorageValue, LoadingStorageValue } from '../storage/types.js';\nimport { regexOrStringMatch } from '../util/cache-predicate.js';\nimport type { RequestInterceptor } from './build.js';\nimport {\n  type ConfigWithCache,\n  createValidateStatus,\n  isMethodIn,\n  updateStaleRequest\n} from './util.js';\n\nexport function defaultRequestInterceptor(axios: AxiosCacheInstance): RequestInterceptor {\n  const onFulfilled: RequestInterceptor['onFulfilled'] = async (config) => {\n    config.id = axios.generateKey(config);\n\n    if (config.cache === false) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: config.id,\n          msg: 'Ignoring cache because config.cache === false',\n          data: config\n        });\n      }\n\n      return config;\n    }\n\n    // merge defaults with per request configuration\n    config.cache = { ...axios.defaults.cache, ...config.cache };\n\n    // ignoreUrls (blacklist)\n    if (\n      typeof config.cache.cachePredicate === 'object' &&\n      config.cache.cachePredicate.ignoreUrls &&\n      config.url\n    ) {\n      for (const url of config.cache.cachePredicate.ignoreUrls) {\n        if (regexOrStringMatch(url, config.url)) {\n          if (__ACI_DEV__) {\n            axios.debug({\n              id: config.id,\n              msg: `Ignored because url (${config.url}) matches ignoreUrls (${config.cache.cachePredicate.ignoreUrls})`,\n              data: {\n                url: config.url,\n                cachePredicate: config.cache.cachePredicate\n              }\n            });\n          }\n\n          return config;\n        }\n      }\n    }\n\n    // allowUrls\n    if (\n      typeof config.cache.cachePredicate === 'object' &&\n      config.cache.cachePredicate.allowUrls &&\n      config.url\n    ) {\n      let matched = false;\n\n      for (const url of config.cache.cachePredicate.allowUrls) {\n        if (regexOrStringMatch(url, config.url)) {\n          matched = true;\n\n          if (__ACI_DEV__) {\n            axios.debug({\n              id: config.id,\n              msg: `Cached because url (${config.url}) matches allowUrls (${config.cache.cachePredicate.allowUrls})`,\n              data: {\n                url: config.url,\n                cachePredicate: config.cache.cachePredicate\n              }\n            });\n          }\n          break;\n        }\n      }\n\n      if (!matched) {\n        if (__ACI_DEV__) {\n          axios.debug({\n            id: config.id,\n            msg: `Ignored because url (${config.url}) does not match any allowUrls (${config.cache.cachePredicate.allowUrls})`,\n            data: {\n              url: config.url,\n              cachePredicate: config.cache.cachePredicate\n            }\n          });\n        }\n        return config;\n      }\n    }\n\n    // Applies sufficient headers to prevent other cache systems to work along with this one\n    //\n    // Its currently used before isMethodIn because if the isMethodIn returns false, the request\n    // shouldn't be cached an therefore neither in the browser.\n    if (config.cache.cacheTakeover) {\n      config.headers[Header.CacheControl] ??= 'no-cache';\n      config.headers[Header.Pragma] ??= 'no-cache';\n      config.headers[Header.Expires] ??= '0';\n    }\n\n    if (!isMethodIn(config.method, config.cache.methods)) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: config.id,\n          msg: `Ignored because method (${config.method}) is not in cache.methods (${config.cache.methods})`\n        });\n      }\n\n      return config;\n    }\n\n    // Assumes that the storage handled staled responses\n    let cache = await axios.storage.get(config.id, config);\n    const overrideCache = config.cache.override;\n\n    // Not cached, continue the request, and mark it as fetching\n    // biome-ignore lint/suspicious/noConfusingLabels: required to break condition in simultaneous accesses\n    ignoreAndRequest: if (\n      cache.state === 'empty' ||\n      cache.state === 'stale' ||\n      cache.state === 'must-revalidate' ||\n      overrideCache\n    ) {\n      // This checks for simultaneous access to a new key. The js event loop jumps on the\n      // first await statement, so the second (asynchronous call) request may have already\n      // started executing.\n      if (axios.waiting.has(config.id) && !overrideCache) {\n        cache = (await axios.storage.get(config.id, config)) as\n          | CachedStorageValue\n          | LoadingStorageValue;\n\n        // @ts-expect-error This check is required when a request has it own cache deleted manually, lets\n        // say by a `axios.storage.delete(key)` and has a concurrent loading request.\n        // Because in this case, the cache will be empty and may still has a pending key\n        // on waiting map.\n        if (cache.state !== 'empty' && cache.state !== 'must-revalidate') {\n          if (__ACI_DEV__) {\n            axios.debug({\n              id: config.id,\n              msg: 'Waiting list had an deferred for this key, waiting for it to finish'\n            });\n          }\n\n          break ignoreAndRequest;\n        }\n      }\n\n      // Create a deferred to resolve other requests for the same key when it's completed\n      const def = deferred<void>();\n      axios.waiting.set(config.id, def);\n\n      // Adds a default reject handler to catch when the request gets aborted without\n      // others waiting for it.\n      def.catch(() => undefined);\n\n      await axios.storage.set(\n        config.id,\n        {\n          state: 'loading',\n          previous: overrideCache\n            ? // Simply determine if the request is stale or not\n              // based if it had previous data or not\n              cache.data\n              ? 'stale'\n              : 'empty'\n            : // Typescript doesn't know that cache.state here can only be 'empty' or 'stale'\n              (cache.state as 'stale' | 'must-revalidate'),\n\n          data: cache.data as any,\n\n          // If the cache is empty and asked to override it, use the current timestamp\n          createdAt: overrideCache && !cache.createdAt ? Date.now() : (cache.createdAt as any)\n        },\n        config\n      );\n\n      if (cache.state === 'stale' || cache.state === 'must-revalidate') {\n        updateStaleRequest(cache, config as ConfigWithCache<unknown>);\n\n        if (__ACI_DEV__) {\n          axios.debug({\n            id: config.id,\n            msg: 'Updated stale request'\n          });\n        }\n      }\n\n      config.validateStatus = createValidateStatus(config.validateStatus);\n\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: config.id,\n          msg: 'Sending request, waiting for response',\n          data: {\n            overrideCache,\n            state: cache.state\n          }\n        });\n      }\n\n      // Hydrates any UI temporarily, if cache is available\n      if (cache.state === 'stale' || (cache.data && cache.state !== 'must-revalidate')) {\n        await config.cache.hydrate?.(cache);\n      }\n\n      return config;\n    }\n\n    let cachedResponse: CachedResponse;\n\n    if (cache.state === 'loading') {\n      const deferred = axios.waiting.get(config.id);\n\n      // The deferred may not exists when the process is using a persistent\n      // storage and cancelled  in the middle of a request, this would result in\n      // a pending loading state in the storage but no current promises to resolve\n      if (!deferred) {\n        // Hydrates any UI temporarily, if cache is available\n        if (cache.data) {\n          await config.cache.hydrate?.(cache);\n        }\n\n        return config;\n      }\n\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: config.id,\n          msg: 'Detected concurrent request, waiting for it to finish'\n        });\n      }\n\n      try {\n        // Deferred can't reuse the value because the user's storage might clone\n        // or mutate the value, so we need to ask it again.\n        // For example with memoryStorage + cloneData\n        await deferred;\n        const state = await axios.storage.get(config.id, config);\n\n        // This is a cache mismatch and should never happen, but in case it does,\n        // we need to redo the request all over again.\n        /* c8 ignore start */\n        if (!state.data) {\n          if (__ACI_DEV__) {\n            axios.debug({\n              id: config.id,\n              msg: 'Deferred resolved, but no data was found, requesting again'\n            });\n          }\n\n          return onFulfilled!(config);\n        }\n        /* c8 ignore end */\n\n        cachedResponse = state.data;\n      } catch (err) {\n        if (__ACI_DEV__) {\n          axios.debug({\n            id: config.id,\n            msg: 'Deferred rejected, requesting again',\n            data: err\n          });\n        }\n\n        // Hydrates any UI temporarily, if cache is available\n        /* c8 ignore start */\n        if (cache.data) {\n          await config.cache.hydrate?.(cache);\n        }\n        /* c8 ignore end */\n\n        // The deferred is rejected when the request that we are waiting rejects its cache.\n        // In this case, we need to redo the request all over again.\n        return onFulfilled!(config);\n      }\n    } else {\n      cachedResponse = cache.data;\n    }\n\n    // The cached data is already transformed after receiving the response from the server.\n    // Reapplying the transformation on the transformed data will have an unintended effect.\n    // Since the cached data is already in the desired format, there is no need to apply the transformation function again.\n    config.transformResponse = undefined;\n\n    // Even though the response interceptor receives this one from here,\n    // it has been configured to ignore cached responses = true\n    config.adapter = function cachedAdapter(): Promise<CacheAxiosResponse> {\n      return Promise.resolve({\n        config,\n        data: cachedResponse.data,\n        headers: cachedResponse.headers,\n        status: cachedResponse.status,\n        statusText: cachedResponse.statusText,\n        cached: true,\n        stale: (cache as LoadingStorageValue).previous === 'stale',\n\n        id: config.id!\n      });\n    };\n\n    if (__ACI_DEV__) {\n      axios.debug({\n        id: config.id,\n        msg: 'Returning cached response'\n      });\n    }\n\n    return config;\n  };\n\n  return {\n    onFulfilled\n  };\n}\n", "import type { CacheAxiosResponse } from '../cache/axios.js';\nimport type { AxiosStorage } from '../storage/types.js';\nimport type { CacheUpdater } from './types.js';\n\n/** Function to update all caches, from CacheProperties.update, with the new data. */\nexport async function updateCache<R, D>(\n  storage: AxiosStorage,\n  data: CacheAxiosResponse<R, D>,\n  cacheUpdater: CacheUpdater<R, D>\n): Promise<void> {\n  // Global cache update function.\n  if (typeof cacheUpdater === 'function') {\n    return cacheUpdater(data);\n  }\n\n  for (const [cacheKey, updater] of Object.entries(cacheUpdater)) {\n    if (updater === 'delete') {\n      await storage.remove(cacheKey, data.config);\n      continue;\n    }\n\n    const value = await storage.get(cacheKey, data.config);\n\n    if (value.state === 'loading') {\n      continue;\n    }\n\n    const newValue = await updater(value, data);\n\n    if (newValue === 'delete') {\n      await storage.remove(cacheKey, data.config);\n      continue;\n    }\n\n    if (newValue !== 'ignore') {\n      await storage.set(cacheKey, newValue, data.config);\n    }\n  }\n}\n", "import type { AxiosResponseHeaders } from 'axios';\nimport { parse } from 'cache-parser';\nimport type { AxiosCacheInstance, CacheAxiosResponse, CacheRequestConfig } from '../cache/axios.js';\nimport type { CacheProperties } from '../cache/cache.js';\nimport { Header } from '../header/headers.js';\nimport type { CachedStorageValue } from '../storage/types.js';\nimport { testCachePredicate } from '../util/cache-predicate.js';\nimport { updateCache } from '../util/update-cache.js';\nimport type { ResponseInterceptor } from './build.js';\nimport { createCacheResponse, isMethodIn } from './util.js';\n\nexport function defaultResponseInterceptor(axios: AxiosCacheInstance): ResponseInterceptor {\n  /**\n   * Rejects cache for an response response.\n   *\n   * Also update the waiting list for this key by rejecting it.\n   */\n  const rejectResponse = async (\n    responseId: string,\n    config: CacheRequestConfig,\n    clearCache: boolean\n  ) => {\n    // Updates the cache to empty to prevent infinite loading state\n    if (clearCache) {\n      await axios.storage.remove(responseId, config);\n    }\n\n    // Rejects the deferred, if present\n    const deferred = axios.waiting.get(responseId);\n\n    if (deferred) {\n      deferred.reject();\n      axios.waiting.delete(responseId);\n    }\n  };\n\n  const onFulfilled: ResponseInterceptor['onFulfilled'] = async (response) => {\n    // When response.config is not present, the response is indeed a error.\n    if (!response?.config) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          msg: 'Response interceptor received an unknown response.',\n          data: response\n        });\n      }\n\n      // Re-throws the error\n      throw response;\n    }\n\n    response.id = response.config.id!;\n    response.cached ??= false;\n\n    const config = response.config;\n    // Request interceptor merges defaults with per request configuration\n    const cacheConfig = config.cache as CacheProperties;\n\n    // Response is already cached\n    if (response.cached) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: response.id,\n          msg: 'Returned cached response'\n        });\n      }\n\n      return response;\n    }\n\n    // Skip cache: either false or weird behavior\n    // config.cache should always exists, at least from global config merge.\n    if (!cacheConfig) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: response.id,\n          msg: 'Response with config.cache falsy',\n          data: response\n        });\n      }\n\n      response.cached = false;\n      return response;\n    }\n\n    // Update other entries before updating himself\n    if (cacheConfig.update) {\n      await updateCache(axios.storage, response, cacheConfig.update);\n    }\n\n    if (!isMethodIn(config.method, cacheConfig.methods)) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: response.id,\n          msg: `Ignored because method (${config.method}) is not in cache.methods (${cacheConfig.methods})`,\n          data: { config, cacheConfig }\n        });\n      }\n\n      return response;\n    }\n\n    const cache = await axios.storage.get(response.id, config);\n\n    if (\n      // If the request interceptor had a problem or it wasn't cached\n      cache.state !== 'loading'\n    ) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: response.id,\n          msg: \"Response not cached and storage isn't loading\",\n          data: { cache, response }\n        });\n      }\n\n      return response;\n    }\n\n    // Config told that this response should be cached.\n    if (\n      // For 'loading' values (previous: stale), this check already ran in the past.\n      !cache.data &&\n      !(await testCachePredicate(response, cacheConfig.cachePredicate))\n    ) {\n      await rejectResponse(response.id, config, true);\n\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: response.id,\n          msg: 'Cache predicate rejected this response'\n        });\n      }\n\n      return response;\n    }\n\n    // Avoid remnant headers from remote server to break implementation\n    for (const header of Object.keys(response.headers)) {\n      if (header.startsWith('x-axios-cache')) {\n        delete response.headers[header];\n      }\n    }\n\n    if (cacheConfig.etag && cacheConfig.etag !== true) {\n      response.headers[Header.XAxiosCacheEtag] = cacheConfig.etag;\n    }\n\n    if (cacheConfig.modifiedSince) {\n      response.headers[Header.XAxiosCacheLastModified] =\n        cacheConfig.modifiedSince === true\n          ? 'use-cache-timestamp'\n          : cacheConfig.modifiedSince.toUTCString();\n    }\n\n    let ttl = cacheConfig.ttl || -1; // always set from global config\n    let staleTtl: number | undefined;\n\n    if (cacheConfig.interpretHeader) {\n      const expirationTime = axios.headerInterpreter(response.headers, axios.location);\n\n      // Cache should not be used\n      if (expirationTime === 'dont cache') {\n        await rejectResponse(response.id, config, true);\n\n        if (__ACI_DEV__) {\n          axios.debug({\n            id: response.id,\n            msg: `Cache header interpreted as 'dont cache'`,\n            data: { cache, response, expirationTime }\n          });\n        }\n\n        return response;\n      }\n\n      if (expirationTime !== 'not enough headers') {\n        if (typeof expirationTime === 'number') {\n          ttl = expirationTime;\n        } else {\n          ttl = expirationTime.cache;\n          staleTtl = expirationTime.stale;\n        }\n      }\n    }\n\n    const data = createCacheResponse(response, cache.data);\n\n    if (typeof ttl === 'function') {\n      ttl = await ttl(response);\n    }\n\n    if (cacheConfig.staleIfError) {\n      response.headers[Header.XAxiosCacheStaleIfError] = String(ttl);\n    }\n\n    if (__ACI_DEV__) {\n      axios.debug({\n        id: response.id,\n        msg: 'Useful response configuration found',\n        data: { cacheConfig, cacheResponse: data }\n      });\n    }\n\n    const newCache: CachedStorageValue = {\n      state: 'cached',\n      ttl,\n      staleTtl,\n      createdAt: Date.now(),\n      data\n    };\n\n    // Define this key as cache on the storage\n    await axios.storage.set(response.id, newCache, config);\n\n    // Resolve all other requests waiting for this response\n    const waiting = axios.waiting.get(response.id);\n\n    if (waiting) {\n      waiting.resolve();\n      axios.waiting.delete(response.id);\n\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: response.id,\n          msg: 'Found waiting deferred(s) and resolved them'\n        });\n      }\n    }\n\n    if (__ACI_DEV__) {\n      axios.debug({\n        id: response.id,\n        msg: 'Response cached',\n        data: { cache: newCache, response }\n      });\n    }\n\n    // Return the response with cached as false, because it was not cached at all\n    return response;\n  };\n\n  const onRejected: ResponseInterceptor['onRejected'] = async (error) => {\n    // When response.config is not present, the response is indeed a error.\n    if (!error.isAxiosError || !error.config) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          msg: 'FATAL: Received an non axios error in the rejected response interceptor, ignoring.',\n          data: error\n        });\n      }\n\n      // We should probably re-request the response to avoid an infinite loading state here\n      // but, since this is an unknown error, we cannot figure out what request ID to use.\n      // And the only solution is to let the storage actively reject the current loading state.\n      throw error;\n    }\n\n    const config = error.config as CacheRequestConfig & { headers: AxiosResponseHeaders };\n    const id = config.id;\n    const cacheConfig = config.cache as CacheProperties;\n    const response = error.response as CacheAxiosResponse | undefined;\n\n    // config.cache should always exist, at least from global config merge.\n    if (!cacheConfig || !id) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          msg: 'Web request returned an error but cache handling is not enabled',\n          data: { error }\n        });\n      }\n\n      throw error;\n    }\n\n    if (!isMethodIn(config.method, cacheConfig.methods)) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id,\n          msg: `Ignored because method (${config.method}) is not in cache.methods (${cacheConfig.methods})`,\n          data: { config, cacheConfig }\n        });\n      }\n\n      // Rejects all other requests waiting for this response\n      await rejectResponse(id, config, true);\n\n      throw error;\n    }\n\n    const cache = await axios.storage.get(id, config);\n\n    if (\n      // This will only not be loading if the interceptor broke\n      cache.state !== 'loading' ||\n      cache.previous !== 'stale'\n    ) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id,\n          msg: 'Caught an error in the request interceptor',\n          data: { cache, error, config }\n        });\n      }\n\n      // Rejects all other requests waiting for this response\n      await rejectResponse(\n        id,\n        config,\n        // Do not clear cache if this request is cached, but the request was cancelled before returning the cached response\n        error.code !== 'ERR_CANCELED' || (error.code === 'ERR_CANCELED' && cache.state !== 'cached')\n      );\n\n      throw error;\n    }\n\n    if (cacheConfig.staleIfError) {\n      const cacheControl = String(response?.headers[Header.CacheControl]);\n      const staleHeader = cacheControl && parse(cacheControl).staleIfError;\n\n      const staleIfError =\n        typeof cacheConfig.staleIfError === 'function'\n          ? await cacheConfig.staleIfError(response, cache, error)\n          : cacheConfig.staleIfError === true && staleHeader\n            ? staleHeader * 1000 //staleIfError is in seconds\n            : cacheConfig.staleIfError;\n\n      if (__ACI_DEV__) {\n        axios.debug({\n          id,\n          msg: 'Found cache if stale config for rejected response',\n          data: { error, config, staleIfError }\n        });\n      }\n\n      if (\n        staleIfError === true ||\n        // staleIfError is the number of seconds that stale is allowed to be used\n        (typeof staleIfError === 'number' && cache.createdAt + staleIfError > Date.now())\n      ) {\n        // re-mark the cache as stale\n        await axios.storage.set(\n          id,\n          {\n            state: 'stale',\n            createdAt: Date.now(),\n            data: cache.data\n          },\n          config\n        );\n        // Resolve all other requests waiting for this response\n        const waiting = axios.waiting.get(id);\n\n        if (waiting) {\n          waiting.resolve();\n          axios.waiting.delete(id);\n\n          if (__ACI_DEV__) {\n            axios.debug({\n              id,\n              msg: 'Found waiting deferred(s) and resolved them'\n            });\n          }\n        }\n\n        if (__ACI_DEV__) {\n          axios.debug({\n            id,\n            msg: 'staleIfError resolved this response with cached data',\n            data: { error, config, cache }\n          });\n        }\n\n        return {\n          cached: true,\n          stale: true,\n          config,\n          id,\n          data: cache.data.data,\n          headers: cache.data.headers,\n          status: cache.data.status,\n          statusText: cache.data.statusText\n        };\n      }\n    }\n\n    if (__ACI_DEV__) {\n      axios.debug({\n        id,\n        msg: 'Received an unknown error that could not be handled',\n        data: { error, config }\n      });\n    }\n\n    // Rejects all other requests waiting for this response\n    await rejectResponse(id, config, true);\n\n    throw error;\n  };\n\n  return {\n    onFulfilled,\n    onRejected\n  };\n}\n", "import type { CacheRequestConfig } from '../cache/axios.js';\nimport { Header } from '../header/headers.js';\nimport type { MaybePromise } from '../util/types.js';\nimport type { AxiosStorage, CachedStorageValue, StaleStorageValue, StorageValue } from './types.js';\n\n/** Returns true if the provided object was created from {@link buildStorage} function. */\nexport const isStorage = (obj: unknown): obj is AxiosStorage =>\n  !!obj && !!(obj as Record<string, boolean>)['is-storage'];\n\nfunction hasUniqueIdentifierHeader(value: CachedStorageValue | StaleStorageValue): boolean {\n  const headers = value.data.headers;\n\n  return (\n    Header.ETag in headers ||\n    Header.LastModified in headers ||\n    Header.XAxiosCacheEtag in headers ||\n    Header.XAxiosCacheLastModified in headers\n  );\n}\n\n/** Returns true if value must be revalidated */\nexport function mustRevalidate(value: CachedStorageValue | StaleStorageValue): boolean {\n  // Must revalidate is a special case and should not serve stale values\n  // We could use cache-control's parse function, but this is way faster and simpler\n  return String(value.data.headers[Header.CacheControl]).includes('must-revalidate');\n}\n\n/** Returns true if this has sufficient properties to stale instead of expire. */\nexport function canStale(value: CachedStorageValue): boolean {\n  if (hasUniqueIdentifierHeader(value)) {\n    return true;\n  }\n\n  return (\n    value.state === 'cached' &&\n    value.staleTtl !== undefined &&\n    // Only allow stale values after the ttl is already in the past and the staleTtl is in the future.\n    // In cases that just createdAt + ttl > Date.now(), isn't enough because the staleTtl could be <= 0.\n    // This logic only returns true when Date.now() is between the (createdAt + ttl) and (createdAt + ttl + staleTtl).\n    // Following the example below:\n    // |--createdAt--:--ttl--:---staleTtl--->\n    // [        past        ][now is in here]\n    Math.abs(Date.now() - (value.createdAt + value.ttl)) <= value.staleTtl\n  );\n}\n\n/**\n * Checks if the provided cache is expired. You should also check if the cache\n * {@link canStale} and {@link mayUseStale}\n */\nexport function isExpired(value: CachedStorageValue | StaleStorageValue): boolean {\n  return value.ttl !== undefined && value.createdAt + value.ttl <= Date.now();\n}\n\nexport interface BuildStorage extends Omit<AxiosStorage, 'get'> {\n  /**\n   * Returns the value for the given key. This method does not have to make checks for\n   * cache invalidation or anything. It just returns what was previous saved, if present.\n   *\n   * @param key The key to look for\n   * @param currentRequest The current {@link CacheRequestConfig}, if any\n   * @see https://axios-cache-interceptor.js.org/guide/storages#buildstorage\n   */\n  find: (\n    key: string,\n    currentRequest?: CacheRequestConfig\n  ) => MaybePromise<StorageValue | undefined>;\n}\n\n/**\n * All integrated storages are wrappers around the `buildStorage` function. External\n * libraries use it and if you want to build your own, `buildStorage` is the way to go!\n *\n * The exported `buildStorage` function abstracts the storage interface and requires a\n * super simple object to build the storage.\n *\n * **Note**: You can only create an custom storage with this function.\n *\n * @example\n *\n * ```js\n * const myStorage = buildStorage({\n *   find: () => {...},\n *   set: () => {...},\n *   remove: () => {...},\n *   clear: () => {...}\n * });\n *\n * const axios = setupCache(axios, { storage: myStorage });\n * ```\n *\n * @see https://axios-cache-interceptor.js.org/guide/storages#buildstorage\n */\nexport function buildStorage({ set, find, remove, clear }: BuildStorage): AxiosStorage {\n  return {\n    //@ts-expect-error - we don't want to expose this\n    'is-storage': 1,\n    set,\n    remove,\n    clear,\n    get: async (key, config) => {\n      let value = await find(key, config);\n\n      if (!value) {\n        return { state: 'empty' };\n      }\n\n      if (\n        value.state === 'empty' ||\n        value.state === 'loading' ||\n        value.state === 'must-revalidate'\n      ) {\n        return value;\n      }\n\n      // Handle cached values\n      if (value.state === 'cached') {\n        if (!isExpired(value)) {\n          return value;\n        }\n\n        // Tries to stale expired value\n        if (!canStale(value)) {\n          await remove(key, config);\n          return { state: 'empty' };\n        }\n\n        value = {\n          state: 'stale',\n          createdAt: value.createdAt,\n          data: value.data,\n          ttl: value.staleTtl !== undefined ? value.staleTtl + value.ttl : undefined\n        };\n\n        await set(key, value, config);\n\n        // Must revalidate is a special case and should not serve stale values\n        if (mustRevalidate(value)) {\n          return { ...value, state: 'must-revalidate' };\n        }\n      }\n\n      // A second check in case the new stale value was created already expired.\n      if (!isExpired(value)) {\n        return value;\n      }\n\n      if (hasUniqueIdentifierHeader(value)) {\n        return value;\n      }\n\n      await remove(key, config);\n      return { state: 'empty' };\n    }\n  };\n}\n", "import { buildStorage, canStale, isExpired } from './build.js';\nimport type { AxiosStorage, StorageValue } from './types.js';\n\n/* c8 ignore start */\n/**\n * Clones an object using the structured clone algorithm if available, otherwise\n * it uses JSON.parse(JSON.stringify(value)).\n */\nconst clone: <T>(value: T) => T =\n  // https://caniuse.com/mdn-api_structuredclone (10/18/2023 92.51%)\n  typeof structuredClone === 'function'\n    ? structuredClone\n    : (value) => JSON.parse(JSON.stringify(value));\n/* c8 ignore stop */\n\n/**\n * Creates a simple in-memory storage. This means that if you need to persist data between\n * page or server reloads, this will not help.\n *\n * This is the storage used by default.\n *\n * If you need to modify it's data, you can do by the `data` property.\n *\n * @example\n *\n * ```js\n * const memoryStorage = buildMemoryStorage();\n *\n * setupCache(axios, { storage: memoryStorage });\n *\n * // Simple example to force delete the request cache\n *\n * const { id } = axios.get('url');\n *\n * delete memoryStorage.data[id];\n * ```\n *\n * @param {boolean | 'double'} cloneData Use `true` if the data returned by `find()`\n *   should be cloned to avoid mutating the original data outside the `set()` method. Use\n *   `'double'` to also clone before saving value in storage using `set()`. Disabled is\n *   default\n * @param {number | false} cleanupInterval The interval in milliseconds to run a\n *   setInterval job of cleaning old entries. If false, the job will not be created.\n *   Disabled is default\n * @param {number | false} maxEntries The maximum number of entries to keep in the\n *   storage. Its hard to determine the size of the entries, so a smart FIFO order is used\n *   to determine eviction. If false, no check will be done and you may grow up memory\n *   usage. Disabled is default\n */\nexport function buildMemoryStorage(\n  cloneData: boolean | 'double' = false,\n  cleanupInterval: number | false = false,\n  maxEntries: number | false = false\n) {\n  const storage = buildStorage({\n    set: (key, value) => {\n      if (maxEntries) {\n        let keys = Object.keys(storage.data);\n\n        // Tries to cleanup first\n        if (keys.length >= maxEntries) {\n          storage.cleanup();\n\n          // Recalculates the keys\n          keys = Object.keys(storage.data);\n\n          // Keeps deleting until there's space\n          while (keys.length >= maxEntries) {\n            // There's always at least one key here, otherwise it would not be\n            // in the loop.\n\n            delete storage.data[keys.shift()!];\n          }\n        }\n      }\n\n      // Clone the value before storing to prevent future mutations\n      // from affecting cached data.\n      storage.data[key] = cloneData === 'double' ? clone(value) : value;\n    },\n\n    remove: (key) => {\n      delete storage.data[key];\n    },\n\n    find: (key) => {\n      const value = storage.data[key];\n\n      return cloneData && value !== undefined ? clone(value) : value;\n    },\n\n    clear: () => {\n      storage.data = Object.create(null);\n    }\n  }) as MemoryStorage;\n\n  storage.data = Object.create(null) as Record<string, StorageValue>;\n\n  // When this program gets running for more than the specified interval, there's a good\n  // chance of it being a long-running process or at least have a lot of entries. Therefore,\n  // \"faster\" loop is more important than code readability.\n  storage.cleanup = () => {\n    const keys = Object.keys(storage.data);\n\n    let i = -1;\n    let value: StorageValue;\n    let key: string;\n\n    // Looping forward, as older entries are more likely to be expired\n    // than newer ones.\n    while (++i < keys.length) {\n      key = keys[i]!;\n      value = storage.data[key]!;\n\n      if (value.state === 'empty') {\n        storage.remove(key);\n        continue;\n      }\n\n      // If the value is expired and can't be stale, remove it\n      if (value.state === 'cached' && isExpired(value) && !canStale(value)) {\n        // this storage returns void.\n\n        storage.remove(key);\n      }\n    }\n  };\n\n  if (cleanupInterval) {\n    storage.cleaner = setInterval(storage.cleanup, cleanupInterval);\n  }\n\n  return storage;\n}\n\nexport interface MemoryStorage extends AxiosStorage {\n  data: Record<string, StorageValue>;\n  /** The job responsible to cleaning old entries */\n  cleaner: ReturnType<typeof setInterval>;\n  /** Tries to remove any invalid entry from the memory */\n  cleanup: () => void;\n}\n", "import type { Method } from 'axios';\nimport { hash } from 'object-code';\nimport type { CacheRequestConfig } from '../cache/axios.js';\nimport type { KeyGenerator } from './types.js';\n\n// Remove first and last '/' char, if present\nconst SLASHES_REGEX = /^\\/|\\/$/g;\n\n/**\n * Builds an generator that receives a {@link CacheRequestConfig} and returns a value\n * hashed by {@link hash}.\n *\n * The value is hashed into a signed integer when the returned value from the provided\n * generator is not a `string` or a `number`.\n *\n * You can return any type of data structure.\n *\n * @example\n *\n * ```js\n * // This generator will return a hash code.\n * // The code will only be the same if url, method and data are the same.\n * const generator = buildKeyGenerator(({ url, method, data }) => ({\n *   url,\n *   method,\n *   data\n * }));\n * ```\n */\nexport function buildKeyGenerator<R = unknown, D = unknown>(\n  generator: (request: CacheRequestConfig<R, D>) => unknown\n): KeyGenerator<R, D> {\n  return (request) => {\n    if (request.id) {\n      return request.id;\n    }\n\n    const key = generator(request);\n\n    if (typeof key === 'string' || typeof key === 'number') {\n      return `${key}`;\n    }\n\n    return `${hash(key)}`;\n  };\n}\n\nexport const defaultKeyGenerator = buildKeyGenerator(({ baseURL, url, method, params, data }) => {\n  // Remove trailing slashes to avoid generating different keys for the \"same\" final url.\n  if (baseURL !== undefined) {\n    baseURL = baseURL.replace(SLASHES_REGEX, '');\n  } else {\n    // just to have a consistent hash\n    baseURL = '';\n  }\n\n  if (url !== undefined) {\n    url = url.replace(SLASHES_REGEX, '');\n  } else {\n    // just to have a consistent hash\n    url = '';\n  }\n\n  if (method !== undefined) {\n    method = method.toLowerCase() as Method;\n  } else {\n    // just to have a consistent hash\n    method = 'get';\n  }\n\n  return {\n    url: baseURL + (baseURL && url ? '/' : '') + url,\n    params: params,\n    method: method,\n    data: data\n  };\n});\n", "import type { AxiosInstance } from 'axios';\nimport { defaultHeaderInterpreter } from '../header/interpreter.js';\nimport { defaultRequestInterceptor } from '../interceptors/request.js';\nimport { defaultResponseInterceptor } from '../interceptors/response.js';\nimport { isStorage } from '../storage/build.js';\nimport { buildMemoryStorage } from '../storage/memory.js';\nimport { defaultKeyGenerator } from '../util/key-generator.js';\nimport type { AxiosCacheInstance } from './axios.js';\nimport type { CacheInstance, CacheProperties } from './cache.js';\n\nexport interface CacheOptions extends Partial<CacheInstance>, Partial<CacheProperties> {}\n\n/**\n * Apply the caching interceptors for a already created axios instance.\n *\n * ```ts\n * const axios = setupCache(axios, OPTIONS);\n * ```\n *\n * The `setupCache` function receives global options and all [request\n * specifics](https://axios-cache-interceptor.js.org/config/request-specifics) ones too.\n * This way, you can customize the defaults for all requests.\n *\n * @param axios The already created axios instance\n * @param config The config for the caching interceptors\n * @returns The same instance with extended typescript types.\n * @see https://axios-cache-interceptor.js.org/config\n */\nexport function setupCache(axios: AxiosInstance, options: CacheOptions = {}): AxiosCacheInstance {\n  const axiosCache = axios as AxiosCacheInstance;\n\n  if (axiosCache.defaults.cache) {\n    throw new Error('setupCache() should be called only once');\n  }\n\n  axiosCache.location = typeof window === 'undefined' ? 'server' : 'client';\n\n  axiosCache.storage = options.storage || buildMemoryStorage();\n\n  if (!isStorage(axiosCache.storage)) {\n    throw new Error('Use buildStorage() function');\n  }\n\n  axiosCache.waiting = options.waiting || new Map();\n\n  axiosCache.generateKey = options.generateKey || defaultKeyGenerator;\n\n  axiosCache.headerInterpreter = options.headerInterpreter || defaultHeaderInterpreter;\n\n  axiosCache.requestInterceptor =\n    options.requestInterceptor || defaultRequestInterceptor(axiosCache);\n\n  axiosCache.responseInterceptor =\n    options.responseInterceptor || defaultResponseInterceptor(axiosCache);\n\n  axiosCache.debug = options.debug || function noop() {};\n\n  // CacheRequestConfig values\n  axiosCache.defaults.cache = {\n    update: options.update || {},\n\n    ttl: options.ttl ?? 1000 * 60 * 5,\n\n    // Although RFC 7231 also marks POST as cacheable, most users don't know that\n    // and may have problems about why their \"create X\" route not working.\n    methods: options.methods || ['get', 'head'],\n\n    cachePredicate: options.cachePredicate || {\n      // All cacheable status codes defined in RFC 7231\n      statusCheck: (status) => [200, 203, 300, 301, 302, 404, 405, 410, 414, 501].includes(status)\n    },\n\n    etag: options.etag ?? true,\n\n    // This option is going to be ignored by servers when ETag is enabled\n    // Checks strict equality to false to avoid undefined-ish values\n    modifiedSince: options.modifiedSince ?? options.etag === false,\n\n    interpretHeader: options.interpretHeader ?? true,\n\n    cacheTakeover: options.cacheTakeover ?? true,\n\n    staleIfError: options.staleIfError ?? true,\n\n    override: options.override ?? false,\n\n    hydrate: options.hydrate ?? undefined\n  };\n\n  // Apply interceptors\n  axiosCache.interceptors.request.use(\n    axiosCache.requestInterceptor.onFulfilled,\n    axiosCache.requestInterceptor.onRejected\n  );\n  axiosCache.interceptors.response.use(\n    axiosCache.responseInterceptor.onFulfilled,\n    axiosCache.responseInterceptor.onRejected\n  );\n\n  return axiosCache;\n}\n", "import { buildStorage, canStale, isExpired } from './build.js';\nimport type { StorageValue } from './types.js';\n\n/**\n * Creates a simple storage. You can persist his data by using `sessionStorage` or\n * `localStorage` with it.\n *\n * **ImplNote**: Without polyfill, this storage only works on browser environments.\n *\n * @example\n *\n * ```js\n * const fromLocalStorage = buildWebStorage(localStorage);\n * const fromSessionStorage = buildWebStorage(sessionStorage);\n *\n * const myStorage = new Storage();\n * const fromMyStorage = buildWebStorage(myStorage);\n * ```\n *\n * @param storage The type of web storage to use. localStorage or sessionStorage.\n * @param prefix The prefix to index the storage. Useful to prevent collision between\n *   multiple places using the same storage.\n */\nexport function buildWebStorage(storage: Storage, prefix = 'axios-cache-') {\n  return buildStorage({\n    clear: () => {\n      for (const key in storage) {\n        if (key.startsWith(prefix)) {\n          storage.removeItem(key);\n        }\n      }\n    },\n\n    find: (key) => {\n      const json = storage.getItem(prefix + key);\n      return json ? (JSON.parse(json) as StorageValue) : undefined;\n    },\n\n    remove: (key) => {\n      storage.removeItem(prefix + key);\n    },\n\n    set: (key, value) => {\n      const save = () => storage.setItem(prefix + key, JSON.stringify(value));\n\n      try {\n        return save();\n      } catch (error) {\n        const allValues: [string, StorageValue][] = Object.entries(\n          storage as Record<string, string>\n        )\n          .filter((item) => item[0].startsWith(prefix))\n          .map((item) => [item[0], JSON.parse(item[1]) as StorageValue]);\n\n        // Remove all expired values\n        for (const value of allValues) {\n          if (value[1].state === 'cached' && isExpired(value[1]) && !canStale(value[1])) {\n            storage.removeItem(value[0]);\n          }\n        }\n\n        // Try save again after removing expired values\n        try {\n          return save();\n        } catch {\n          // Storage still full, try removing the oldest value until it can be saved\n\n          // Descending sort by createdAt\n          const sortedItems = allValues.sort(\n            (a, b) => (a[1].createdAt || 0) - (b[1].createdAt || 0)\n          );\n\n          for (const item of sortedItems) {\n            storage.removeItem(item[0]);\n\n            try {\n              return save();\n            } catch {\n              // This key didn't free all the required space\n            }\n          }\n        }\n\n        // Clear the cache for the specified key\n        storage.removeItem(prefix + key);\n      }\n    }\n  });\n}\n"],
  "mappings": ";;;IACaA,IAAqBC,OAAO,cAAA;AAAA,SAAA,EAAAC,IAAAC,IAAA;AAAA,GAAA,QAAAA,MAAAA,KAAAD,GAAA,YAAAC,KAAAD,GAAA;AAAA,WAAAE,KAAA,GAAAC,KAAA,IAAA,MAAAF,EAAA,GAAAC,KAAAD,IAAAC,KAAA,CAAAC,GAAAD,EAAA,IAAAF,GAAAE,EAAA;AAAA,SAAAC;AAAA;AAAA,SCDzBC,EAAWC,IAAAA;AACzB,UACkB,YAAA,OAARA,MAAmC,YAAA,OAARA,QAClCA,KAAMC,OAAOD,EAAAA,MAAS,KACtBA,KAAiBE;AAEtB;AAAA,SAEgBC,EAASH,IAAAA;AACvB,SAAA,SACEA,MACe,YAAA,OAARA,MACS,YAAA,OAARA,MAA4B,YAARA;AAEhC;ACVA,IAAMI,IAASH;AAUC,SAAAI,EAAMC,IAAAA;AACpB,MAAMC,IAAuBC,OAAOC,eAAe,CAAA,GAAIhB,GAAoB,EACzEiB,YAAAA,OACAC,OAAO,EAAA,CAAA;AAGT,MAAA,CAAKL,MAAkC,YAAA,OAAdA,GACvB,QAAOC;AAGT,MAAMK,IAAAA,SDRwBN,IAAAA;AAI9B,aAA0BO,IAHpBD,KAAyC,CAAA,GAG/CE,KAAAA,SAAAA,IAAAA,IAAAA;AAAAA,UAAAA,KAAAA,eAAAA,OAAAA,UAAAA,GAAAA,OAAAA,QAAAA,KAAAA,GAAAA,YAAAA;AAAAA,UAAAA,GAAAA,SAAAA,KAAAA,GAAAA,KAAAA,EAAAA,GAAAA,KAAAA,KAAAA,EAAAA;AAAAA,UAAAA,MAAAA,QAAAA,EAAAA,MAAAA,KAAAA,SAAAA,IAAAA,IAAAA;AAAAA,YAAAA,IAAAA;AAAAA,cAAAA,YAAAA,OAAAA,GAAAA,QAAAA,EAAAA,IAAAA,EAAAA;AAAAA,cAAAA,KAAAA,OAAAA,UAAAA,SAAAA,KAAAA,EAAAA,EAAAA,MAAAA,GAAAA,EAAAA;AAAAA,iBAAAA,aAAAA,MAAAA,GAAAA,gBAAAA,KAAAA,GAAAA,YAAAA,OAAAA,UAAAA,MAAAA,UAAAA,KAAAA,MAAAA,KAAAA,EAAAA,IAAAA,gBAAAA,MAAAA,2CAAAA,KAAAA,EAAAA,IAAAA,EAAAA,IAAAA,EAAAA,IAAAA;QAAAA;MAAAA,EAAAA,EAAAA,IAAAA;AAAAA,QAAAA,OAAAA,KAAAA;AAAAA,YAAAA,KAAAA;AAAAA,eAAAA,WAAAA;AAAAA,iBAAAA,MAAAA,GAAAA,SAAAA,EAAAA,MAAAA,KAAAA,IAAAA,EAAAA,MAAAA,OAAAA,OAAAA,GAAAA,IAAAA,EAAAA;QAAAA;MAAAA;AAAAA,YAAAA,IAAAA,UAAAA,uIAAAA;IAAAA,EAFeR,GAAUS,YAAAA,EAAcC,QAAQ,QAAQ,EAAA,EAAIC,MAAM,GAAA,CAAA,GAAA,EAEvCJ,KAAAC,GAAAA,GAAAI,QAAE;AAAAC,UAAAA,IACpBF,KADQJ,GAAAF,MACMM,MAAM,KAAK,CAAA;AAC/BL,MAAAA,GAAQK,GAAM,CAAA,CAAA,IAAA,SAAGE,KAAGF,GAAM,CAAA,MAAEE;IAC9B;AAEA,WAAOP;EACT,ECFkCN,EAAAA,GAE1Bc,IAASR,EAAQ,SAAA,GACjBS,IAAWT,EAAQ,WAAA,GACnBU,IAAWV,EAAQ,WAAA,GACnBW,IAAUX,EAAQ,UAAA,GAClBY,IAAeZ,EAAQ,gBAAA,GACvBa,IAAuBb,EAAQ,wBAAA;AAkErC,SAhEIT,EAASS,EAAmB,SAAA,MAC9BL,EAAOmB,YAAAA,OAGL3B,EAAWqB,CAAAA,MACbb,EAAOa,SAAShB,EAAOgB,CAAAA,IAGrBrB,EAAWsB,CAAAA,MACbd,EAAOc,WAAWjB,EAAOiB,CAAAA,IAGvBtB,EAAWuB,CAAAA,MACbf,EAAOe,WAAWlB,EAAOkB,CAAAA,IAGvBnB,EAASS,EAAQ,iBAAA,CAAA,MACnBL,EAAOoB,iBAAAA,OAGLxB,EAASS,EAAQ,iBAAA,CAAA,MACnBL,EAAOqB,iBAAAA,OAGLzB,EAASS,EAAQ,UAAA,CAAA,MACnBL,EAAOsB,UAAAA,OAGL1B,EAASS,EAAQ,UAAA,CAAA,MACnBL,EAAOuB,UAAAA,OAGL3B,EAASS,EAAQ,cAAA,CAAA,MACnBL,EAAOwB,cAAAA,OAGL5B,EAASS,EAAQ,gBAAA,CAAA,MACnBL,EAAOyB,eAAAA,OAGL7B,EAASS,EAAiB,OAAA,MAC5BL,EAAM,UAAA,OAGJJ,EAASS,EAAQ,kBAAA,CAAA,MACnBL,EAAO0B,kBAAAA,OAGL9B,EAASS,EAAgB,MAAA,MAC3BL,EAAAA,SAAAA,OAGER,EAAWwB,CAAAA,MACbhB,EAAOgB,UAAUnB,EAAOmB,CAAAA,IAGtBxB,EAAWyB,CAAAA,MACbjB,EAAOiB,eAAepB,EAAOoB,CAAAA,IAG3BzB,EAAW0B,CAAAA,MACblB,EAAOkB,uBAAuBrB,EAAOqB,CAAAA,IAGhClB;AACT;;;AGjGa,IAAA2B,KAAkBC,OAAAA;AAAAA,SCGfC,KAAAA;AACd,MAAIC,IACAC,IAEEC,KAAU,IAAIC,QAAW,SAACC,IAAKC,IAAAA;AACnCL,IAAAA,KAAUI,IACVH,KAASI;EACX,CAAA;AAMA,SAJAH,GAAQF,UAAUA,IAClBE,GAAQD,SAASA,IACjBC,GAAQL,EAAAA,IAAmB,GAEpBK;AACT;;;SElBgBI,GAAYC,IAAWC,IAAAA;AACrC,SAAOD,KAAIC,KAAI,IAAA;AACjB;ACwBgB,SAAAC,GAAKC,IAAcC,IAAAA;AACjC,MAAIC,KAAI;AAGR,MACiB,YAAA,OAARF,MACC,SAARA,OACCA,GAAIG,aAAaC,OAAOC,UAAUF,YACjCH,GAAIG,aAAaG,MAAMD,UAAUF,WACnC;AACKF,IAAAA,OACHA,KAAO,oBAAIM;AAMb,aAFMC,IAAOJ,OAAOI,KAAKR,EAAAA,EAAKS,KAAKb,EAAAA,GAE1Bc,KAAI,GAAGA,KAAIF,EAAKG,QAAQD,MAAK;AACpC,UAAME,IAAMJ,EAAKE,EAAAA,GACXG,IAAQb,GAAIY,CAAAA;AAOlB,UALAV,KAAS,KAAJA,KAAUH,GAAKa,GAAKX,EAAAA,GAMN,YAAA,OAAVY,KACG,SAAVA,MACCb,GAAIG,aAAaC,OAAOC,UAAUF,YACjCH,GAAIG,aAAaG,MAAMD,UAAUF,WACnC;AACA,YAAIF,GAAKa,IAAID,CAAAA,EACX;AAGFZ,QAAAA,GAAKc,IAAIF,CAAAA;MACX;AAGAX,MAAAA,KAAS,KAAJA,KAAUH,GAAKc,GAAOZ,EAAAA;IAC7B;AAKA,WAFS,KAAJC,KAAUH,GAAKC,GAAIgB,aAAaf,EAAAA;EAGvC;AAEA,MAAIgB,IAAAA,OAAgBjB;AAEpB,MAAA;AACMA,IAAAA,cAAekB,OACjBD,KAAUjB,GAAImB,QAAAA,IAEdF,KAAUG,OAAOpB,EAAAA;EAErB,SAASqB,IAAAA;AACPJ,SAAUG,OAAOhB,OAAOkB,OAAO,CAAA,GAAItB,EAAAA,CAAAA;EACrC;AAEA,WAASU,IAAI,GAAGA,IAAIO,EAAON,QAAQD,IACjCR,CAAAA,KAAS,KAAJA,KAAUe,EAAOM,WAAWb,CAAAA;AAGnC,SAAOR;AACT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EErFE,yBAA8BsB;AAE9B,CAAA;AAGE,IAAA,2BAAA,CAAA,SAAA,aAAA;AACE,MAAA,CAAA,QAAA,QAAA;AACAC,QAAGC,eACAC,QAAO,OAAA,YAAA;AACV,MAAA,cAAA;AACCC,UAAAA,KAAQ,EAAK,OAAQ,YAAe,CACrC;AACA;;MAGF,GAAA,WAAOC,GAAS;MAEd,aAAA,YAAA,GAAA;MAAA;AACA,aAAA;;QAEEC,GAAAA,WAAc;AAKhB,aAAMC;QAEN,OAAO,MAAA,KAAA,KAAA,KAAA;MACLD;IACI;AACA,QAAA,GAAG,WAAUE,QAAW;AAE5B,YAAA,MAAA,QAAA,OAAA,GAAA;aACK;QACH,OAAA;;WAEA,GAAA,SAAA,OAAA,GAAA,KAAA;YAAA,GAAA,SAAA;;QAEA;;;;;;UAYJC,GAAAA,aAAS,SAAA,GAAA,WAAA,MAAA,GAAA,yBAAA,SAAA,GAAA,uBAAA,MAAA;;MACX;IACA;EAA6BH;AAAqB,QAAG,UAAA,QAAY,OAAA,OAAA;AACnE,MAAA,SAAA;AAEA,UAAO,eAAA,KAAoB,MAAA,OAAA,OAAA,CAAA,IAAA,KAAA,IAAA;AAC7B,WAAA,gBAAA,IAAA;;;;;;;;;;;;;;;;AC3DA,WAAA;EACO;AAIL,SAAI,SAAOI,MAAS,MAAK,SAAY;;eAIlB,mBAAA,UAAA,WAAA;MAAEC,OAAAA,cAAa,YAAA;AAAEC,WAAAA,UAAAA,QAAAA;EAAe;AAEnD,QACGC;IAGD;IACF;IAEA;EACE,IAAA;AAAmE,MAAA,eAAAC,CAAAA,MAAAA,YAAA,SAAA,MAAA,KAAA,iBAAA,CAAA,MAAA,cAAA,QAAA,GAAA;WAE/D;;AAKA,MAAA,iBAAY;AACd,eAAA,CAAA,QAAA,UAAA,KAAA,OAAA,QAAA,eAAA,GAAA;AACF,UAAA;AACF,UAAA,CAAA,MAAA;;SAEA,wBAAW,SAAA,QAAA,OAAA,YAAA,CAAA,MAAA,OAAA,wBAAA,SAAA,QAAA,MAAA;MAAA,GAAA;AACb,eAAA;MAEA;;;;;AAeE,SAAOC,mBAAmBC,cAAa,WAAA;AACzC,MAAA,wBAAA,QAAA;;AC5CA,WAAA,aAAA,KAAA,SAAA;;;AAGG;AAcDC,SAAAA,qBAAgBA,aAAyB;AACzC,SAAOC,cAAWC,YAAY,YAAW,MAAKF,KAAAA,WAAc,MAAA,YAAA,UAAA,OAAA,SAAA,OAAA,WAAA;AAC9D;;;AASG,SAAA,WAAA,KAAA,YAAA,WAAA,aAAA;AACa;SAMkBG,mBAAY,OAAA,QAAA;AAE5C,SAAIC,YAAM,OAAA,UAAA,CAAA;AAAA,QAAAC;IACR;IAEA;MACEF,OAAOpB;AACT,MAAA,MAAA;AACF,QAAA;AAEA,UAAIuB,YAAe,SAAA,QAAA,cAAA,MAAA,SAAA,OAAA,SAAA,YAAA,QAAA,OAAA,IAAA,IAAA;AACjBH,QAAAA,WAAeI;AAET,aAAA,QAAA,OAAA,WAAA,IAAA;IACClB;EAGT;AACF,MAAA,eAAA;AAEA,WAAA,QAAA,OAAA,eAAA,IAAA,kBAAA;;;;EAGG;AACa;AAQZmB,SAAAA,oBAAkBC,UAAcC,eAAM;AACtCF,MAAAA,SAASG,WAAaF,OAAAA,eAAcE;AAGpCH,aAASzB,SAAO;AAKhB,aAAA,OAAA,cAAA;AACA,aAAO0B,SAAAA,cAAa;AACtB,aAAA,aAAA,cAAA;AAGA,aAAO,UAAA,SAAA,CAAA,GAAA,cAAA,SAAA,SAAA,OAAA;AAELC,WAAM;;SAGP;IACH,MAAA,SAAA;;ICpFM,YAAUE,SAAAA;IACd,SAAMC,SAAiD;;AAGrD;AAUA,SAAA,0BAAA,OAAA;AAEA,QAAA,cAAA,OAAA,WAAA;AACAV,WAAOd,KAAK,MAAAyB,YAAQC,MAAMC;AAE1B,QAAA,OAAA,UAAA,OAAA;AACA,aACE;;AAiBI,WAAA,QAAOb,SAAM,CAAA,GAAA,MAAA,SAAA,OAAA,OAAA,KAAA;AAEjB,QAAA,OAAA,OAAA,MAAA,mBAAA,YAAA,OAAA,MAAA,eAAA,cAAA,OAAA,KAAA;AACF,iBAAA,OAAA,OAAA,MAAA,eAAA,YAAA;AAEA,YAAA,mBAAA,KAAA,OAAA,GAAA,GAAA;AAEE,iBAAOA;QAIP;MAEA;;AAcI,QAAA,OAAA,OAAA,MAAA,mBAAA,YAAA,OAAA,MAAA,eAAA,aAAA,OAAA,KAAA;AACF,UAAA,UAAA;AACF,iBAAA,OAAA,OAAA,MAAA,eAAA,WAAA;AAEA,YAAKc,mBAAS,KAAA,OAAA,GAAA,GAAA;AAWZ,oBAAOd;AACT;QACF;MAEA;AACA,UAAA,CAAA,SAAA;AACA,eAAA;MACA;IACA;AAIA,QAAA,OAAA,MAAA,eAAA;AAEA,UAAKe,iBAAkBC,sBAAqBC,uBAAU,kBAAA,gBAAA,uBAAA,kBAAA,iBAAA;AAQpD,OAAA,yBAAa,kBAAA,OAAA,SAAA,uBAAA,OAAA,YAAA,MAAA,OAAA,wBAAA,gBAAA,oBAAA,IAAA;AACf,OAAA,yBAAA,mBAAA,OAAA,SAAA,iBAAA,OAAA,MAAA,MAAA,OAAA,wBAAA,iBAAA,cAAA,IAAA;AAEA,OAAA,yBAAA,mBAAA,OAAA,SAAA,kBAAA,OAAA,OAAA,MAAA,OAAA,wBAAA,iBAAA,eAAA,IAAA;IACA;AACA,QAAA,CAAA,WAAMC,OAAgBlB,QAAOd,OAAMiC,MAAQ,OAAA,GAAA;AAE3C,aAAA;IACA;AAOE,QAAA,QAAA,MAAA,MAAA,QAAA,IAAA,OAAA,IAAA,MAAA;AACA,UAAA,gBAAA,OAAA,MAAA;AAGEjC,qBAAe0B,KAAAA,MAAMQ,UAAYpB,WAAWA,MAErB,UAAA,WAAA,MAAA,UAAA,qBAAA,eAAA;AAKvB,UAAA,MAAA,QAAA,IAAA,OAAA,EAAA,KAAA,CAAA,eAAA;AACA,gBAAId,MAAMmC,MAAU,QAAO,IAAInC,OAAMmC,IAAK,MAAK;AAajD,YAAMC,MAAMC,UAAgB,WAAA,MAAA,UAAA,mBAAA;AAC5BX,gBAAMY;QAEN;MACA;AAGA,YAAMZ,MAAMQ,GAAQK;AAGhBJ,YAAAA,QAAO,IAAS,OAAA,IAAA,GAAA;AAGZ,UAAA,MAAA,MAAA,MAAA;AACAnC,YAAAA,MAAU,QACR,IAAO,OACP,IAAO;QACT,OAAA;QACCA,UAAMmC;;;UAKXK,MAAAA,OAAWR,UAAAA;;;UAKf,MAAIhC;;QACFyC,MAAAA,MAAAA;;QAUF3B,WAAO4B,iBAAiBC,CAAAA,MAAAA,YAAqB7B,KAAO4B,IAAAA,IAAAA,MAAe;MAanE,GAAA,MAAA;AACA,UAAI1C,MAAMmC,UAAU,WAAYnC,MAAM4C,UAAQ5C,mBAAgB;AAC5D,2BAAkB,OAAC6C,MAAO;MAC5B;AAEA,aAAO/B,iBAAM,qBAAA,OAAA,cAAA;AAGf,UAAIgC,MAAAA,UAA8B,WAAA,MAAA,QAAA,MAAA,UAAA,mBAAA;AAE9B9C,eAAMmC,OAAK,MAAK,WAAW,OAAA,SAAA,OAAA,MAAA,QAAA,KAAA;MAC7B;AAEA,aAAA;IACA;AACA,QAAA;QACA,MAAKE,UAAU,WAAA;AACb,YAAA,WAAA,MAAA,QAAA,IAAA,OAAA,EAAA;AAKA,UAAA,CAAA,UAAa;AAUf,YAAI,MAAA,MAAA;AACF,iBAAA,OAAA,MAAA,WAAA,OAAA,SAAA,OAAA,MAAA,QAAA,KAAA;QACA;AACA,eAAA;MACA;AACA,UAAA;AAKA,cAAKF;AACH,cA1PV,QA+PU,MAAA,MAAA,QAAA,IAAA,OAAA,IAAA,MAAA;AAMFW,YAAAA,CAAAA,MAAAA,MAAiBX;AACjB,cAAA,MAAY;AASZ,iBAAA,YAAA,MAAA;QACA;AAEE,yBAAanC,MAAM6C;MACrB,SAAA,KAAA;AAIA,YAAA,MAAA,MAAA;AACA,iBAAOrB,OAAAA,MAAaV,WAAO,OAAA,SAAA,OAAA,MAAA,QAAA,KAAA;QAC7B;AAKF,eAAA,YAAA,MAAA;MACA;IACA,OAAA;AACAA,uBAAOiC,MAAiB;IAExB;WAIIjC,oBAAM;WAGNO,UAAQyB,SAAc,gBAAO;aAC7BxB,QAAYwB,QAAAA;QACZE;QACAC,MAAK,eAAyC;QAE9CC,SAAIpC,eAAOoC;QACX,QAAA,eAAA;QACH,YAAA,eAAA;QASD,QAAOpC;QACR,OAAA,MAAA,aAAA;QAED,IAAO,OAAA;MACLU,CAAAA;IACD;AACH,WAAA;;AC5TA,SAAA;IACO;EAKL;AACA;AAIA,eAAY2B,YAAUC,SAAYC,MAAM,cAASC;MAE7C,OAAMpB,iBAAeiB,YAAerC;AACpC,WAAA,aAAA,IAAA;EACF;AAEA,aAAMyC,CAAAA,UAAcrB,OAAO,KAAKiB,OAAAA,QAAerC,YAAO,GAAA;AAEtD,QAAIyC,YAAW,UAAK;AAClB,YAAA,QAAA,OAAA,UAAA,KAAA,MAAA;AACF;IAEA;AAEA,UAAIC,QAAQ,MAAK,QAAU,IAAA,UAAA,KAAA,MAAA;QACzB,MAAMtB,UAAQuB,WAAe;AAC7B;IACF;AAEA,UAAID,WAAa,MAAA,QAAU,OAAA,IAAA;QACzB,aAAcjB,UAAIY;AACpB,YAAA,QAAA,OAAA,UAAA,KAAA,MAAA;AACF;IACF;;AC3BM,YAAUO,QAAAA,IAAAA,UAAAA,UAAoD,KAAA,MAAA;IAClE;;;AAIG,SAAA,2BAAA,OAAA;AAWD,QAAA,iBAAA,OAAA,YAAA,QAAA,eAAA;AAGA,QAAIrB,YAAU;AACZA,YAAAA,MAASsB,QAAQ,OAAA,YAAA,MAAA;IACjBjC;AAEH,UAAA,WAAA,MAAA,QAAA,IAAA,UAAA;AAED,QAAMF,UAAAA;AAAqE,eAAAoC,OAAAA;AACzE,YAAA,QAAA,OAAA,UAAA;IACA;EAQE;AACA,QAAA,cAAc,OAAA,aAAA;AAChB,QAAA;AAGA,QAAAA,EAAAA,YAAA,QAAAzC,SAAe,SAAA;AAGf,YAAA;IACA;AAEA,aAAA,KAAA,SAAA,OAAA;AACA,KAAA,mBAAmB,SAAE,WAAA,OAAA,mBAAA,SAAA,SAAA;AAQnB,UAAA,SAAOA,SAAQ;AAGjB,UAAA,cAAA,OAAA;AAEA,QAAI,SAAC0C,QAAa;AAShB1C,aAAAA;IACA;AAIF,QAAI0C,CAAAA,aAAYC;AACd,eAAMC,SAAYrC;AACpB,aAAA;IAEA;AAUA,QAAA,YAAA,QAAA;AAEA,YAAM1B,YAAc0B,MAAMQ,SAAQ8B,UAAI7C,YAAmB,MAAC;IAE1D;AACE,QAAA,CAAA,WAAA,OAAA,QAAA,YAAA,OAAA,GAAA;AACAnB,aAAMmC;IAUN;AACF,UAAA,QAAA,MAAA,MAAA,QAAA,IAAA,SAAA,IAAA,MAAA;AAEA;;MAEE,MAAA,UAAA;MAAA;AACCnC,aAAM4C;;AAaT;;MAGA,CAAA,MAAK,QAAMqB,CAAM,MAAIZ,mBAAqB3D,UAAU,YAAA,cAAA;MAAA;AAClD,YAAIuE,eAAiB,SAAC,IAAA,QAAkB,IAAA;AACtC,aAAA;IACF;AAGF,eAAIJ,UAAgB,OAAIA,KAAAA,SAAgB,OAAS,GAAE;AACjD1C,UAAAA,OAASzB,WAAQwB,eAAOgD,GAAgB;AAC1C,eAAA,SAAA,QAAA,MAAA;MAEA;;AAKA,QAAA,YAAA,QAAA,YAAA,SAAA,MAAA;AAEA,eAAUL,QAAAA,OAAe,eAAO,IAAA,YAAA;IAChC;AAEA,QAAIA,YAAYM,eAAe;AAC7B,eAAMC,QAAAA,OAAiB1C,uBAAwBP,IAAAA,YAAgB,kBAAiB,OAAA,wBAAA,YAAA,cAAA,YAAA;IAEhF;QACA,MAAIiD,YAAc,OAAK;QACrB;AAUA,QAAA,YAAOjD,iBAAQ;AACjB,YAAA,iBAAA,MAAA,kBAAA,SAAA,SAAA,MAAA,QAAA;AAGE,UAAA,mBAAWiD,cAAmB;AAC5BC,cAAG,eAAGD,SAAc,IAAA,QAAA,IAAA;AACtB,eAAO;;UAELE,mBAAWF,sBAAoB;AACjC,YAAA,OAAA,mBAAA,UAAA;AACF,gBAAA;QACF,OAAA;AAEMxB,gBAAI,eAAG2B;AAET,qBAAU,eAAiB;QAC7BF;MACF;IAEA;UACElD,OAASzB,oBAAe8E,UAAAA,MAAuB,IAAIC;AACrD,QAAA,OAAA,QAAA,YAAA;AAUA,YAAMC,MAAQ,IAAuB,QAAA;IACnCvC;QACAkC,YAAG,cAAA;AACHC,eAAQ,QAAA,OAAA,uBAAA,IAAA,OAAA,GAAA;IACR9B;AACAI,UAAAA,WAAAA;MACD,OAAA;MAED;MACA;MAEA,WAAA,KAAA,IAAA;MACA;IAEA;UAEElB,MAAMY,QAAQqC,IAAOxD,SAAS+B,IAAG,UAAA,MAAA;AAkBnC,UAAA,UAAA,MAAA,QAAA,IAAA,SAAA,EAAA;AACA,QAAA,SAAO/B;AACR,cAAA,QAAA;AAED,YAAMyD,QAAU,OAA6CC,SAAS,EAAA;IACpE;AASE,WAAA;EACA;AACA,QAAA,aAAA,OAAA,UAAA;AAEF,QAAA,CAAA,MAAA,gBAAA,CAAA,MAAA,QAAA;AAKA,YAAM1D;IAEN;AACA,UAAK0C,SAAAA,MAAgBX;AAQnB,UAAA,KAAM2B,OAAK;AACb,UAAA,cAAA,OAAA;AAEA,UAAKhD,WAAWf,MAAOgB;AAUrB,QAAA,CAAA,eAAMgD,CAAAA,IAAiB;AAEvB,YAAMD;IACR;AAEA,QAAA,CAAA,WAAc,OAAMnD,QAAMQ,YAAgBpB,OAAO,GAAA;AAG/C,YAAA,eAAA,IAAA,QAAA,IAAA;AACAd,YAAMmC;IAWN;AACA,UAAA,QAAM2C,MAAAA,MACF,QACI,IAAA,IAAA,MAAA;AACN;;MAIF,MAAA,UAAW,aAAA,MAAA,aAAA;MAAA;AAGb,YAAIjB;QAAYkB;QAAAA;;QAEd,MAAMC,SAAAA,kBAA0B,MAAIC,SAAMC,kBAAcH,MAAY,UAAA;MAAA;AAEpE,YAAMA;;QAeN,YACEA,cAAqB;AACrB,YAAA,eAAA,OAAA,YAAA,OAAA,SAAA,SAAA,QAAA,OAAA,YAAA,CAAA;AACC,YAAA,cAAmB,gBAAiB/E,EAAMwC,YAAYuC,EAAAA;AAEvD,YAAA,eAAA,OAAA,YAAA,iBAAA,aAAA,MAAA,YAAA,aAAA,UAAA,OAAA,KAAA,IAAA,YAAA,iBAAA,QAAA,cAAA,cAAA,MACA,YAAY7C;AAGRC,UAAAA,iBAAc;aAEdS,iBAAYA,YAAAA,MAAAA,YAAAA,eAAAA,KAAAA,IAAAA,GAAAA;AAIhB,cAAA,MAAA,QAAA,IAAA,IAAA;UACA,OAAMN;UAEN,WAAa,KAAA,IAAA;UACXA,MAAAA,MAAQ6C;QACRzD,GAAAA,MAAMY;AAkBR,cAAA,UAAO,MAAA,QAAA,IAAA,EAAA;AACLU,YAAAA,SAAQ;AACRC,kBAAO,QAAI;AACXnC,gBAAM,QAAA,OAAA,EAAA;;AAEN8B,eAAI;UACJlD,QAAO;UACP2B,OAAM;UACNC;UACD;UACH,MAAA,MAAA,KAAA;UACF,SAAA,MAAA,KAAA;UAUA,QAAA,MAAA,KAAA;UACMwD,YAAAA,MAAiB,KAAEhE;QAEzB;MACD;IAED;AAEE8D,UAAAA,eAAAA,IAAAA,QAAAA,IAAAA;AACD,UAAA;EACH;;IC9YA;IACaQ;EAGb;AACE;AAUF,IAAA,YAAA,SAAA,CAAA,CAAA,OAAA,CAAA,CAAA,IAAA,YAAA;AACM,SAAUC,0BAA4D,OAAA;AAC1E,QAAA,UAAA,MAAA,KAAA;AACA,SAAA,OAAA,QAAA,WAAA,OAAA,gBAAA,WAAA,OAAA,mBAAA,WAAA,OAAA,2BAAA;AACA;AAGF,SAAA,eAAA,OAAA;AAGI,SAAA,OAAW,MAAA,KAAA,QAAA,OAAA,YAAA,CAAA,EAAA,SAAA,iBAAA;AACb;AAKE,SAAA,SAAA,OAAA;AACA,MAAA,0BAAA,KAAA,GAAA;AACA,WAAA;EACA;AACA,SAAA,MAAA,UAAA,YAAA,MAAA,aAAA;;;;;;EASD,KAAA,IAAA,KAAA,IAAA,KAAA,MAAA,YAAA,MAAA,IAAA,KAAA,MAAA;AACG;;;;AA2CiE,SAAA,aAAA;EACrE;EACE;EACA;;;SAGK;;kBAES;;;IAGDlD;SAAgB,OAAA,KAAA,WAAA;AAC3B,UAAA,QAAA,MAAA,KAAA,KAAA,MAAA;AAEA,UACEoB,CAAAA,OAAMpB;AAIN,eAAOoB;UACT,OAAA;QAEA;MACA;AACE,UAAA,MAAK+B,UAAU/B,WAAQ,MAAA,UAAA,aAAA,MAAA,UAAA,mBAAA;AACrB,eAAA;MACF;AAGA,UAAA,MAAKgC,UAAShC,UAAQ;AACpB,YAAA,CAAA,UAAaiC,KAAK1E,GAAAA;AAClB,iBAAO;QAAEqB;AACX,YAAA,CAAA,SAAA,KAAA,GAAA;AAEAoB,gBAAQ,OAAA,KAAA,MAAA;AACNpB,iBAAO;YACPK,OAAS;UACTI;QACAyB;gBACD;UAED,OAAS;UAET,WAAA,MAAA;UACA,MAAIgB,MAAAA;UACF,KAAA,MAAA5D,aAAY8B,SAAK,MAAA,WAAA,MAAA,MAAA;QAAEpB;AAAwB,cAAA,IAAA,KAAA,OAAA,MAAA;AAE/C,YAAA,eAAA,KAAA,GAAA;AAEA,iBAAA,SAAA,CAAA,GAAA,OAAA;YACKmD,OAAAA;UACH,CAAA;QACF;MAEA;AAEA,UAAA,CAAA,UAAA,KAAA,GAAA;AAEA,eAAM7B;MACN;AAAStB,UAAAA,0BAAO,KAAA,GAAA;AAAS,eAAA;MAC3B;AACD,YAAA,OAAA,KAAA,MAAA;AACH,aAAA;;MCxJA;IACA;;;;;;;AAuDQ,SAAA,mBAAA,YAAA,OAAA,kBAAA,OAAA,aAAA,OAAA;AACA,QAAA,UAASsD,aAAUC;UACjBxD,KAAAA,UAAe;AAEf,UAAA,YAAA;YACAyD,OAAOtC,OAAOsC,KAAKzD,QAAQU,IAAK;AAGhC,YAAA,KAAO+C,UAAKF,YAAUC;AACpB,kBAAA,QAAA;iBAGA,OAAOxD,KAAQU,QAAUgD,IAAAA;AAE7B,iBAAA,KAAA,UAAA,YAAA;AAIF,mBAAA,QAAA,KAAA,KAAA,MAAA,CAAA;UACA1D;QACD;MAEDuB;AAIAoC,cAAU,KAAI,GAAA,IAAA,cAAA,WAAA,MAAA,KAAA,IAAA;IACZ;YAEA,SAAOC;AACR,aAAA,QAAA,KAAA,GAAA;IAEDC;UACE7D,SAAQU;AACV,YAAA,QAAA,QAAA,KAAA,GAAA;AACiB,aAAA,aAAA,UAAA,SAAA,MAAA,KAAA,IAAA;IAEnBV;IAEA,OAAA,MAAA;AACA,cAAA,OAAA,uBAAA,OAAA,IAAA;IACA;EACAA,CAAAA;UACQyD,OAAOtC,uBAAOsC,OAAKzD,IAAAA;AAMzB,UAAA,UAAA,MAAA;AACA,UAAA,OAAA,OAAA,KAAA,QAAA,IAAA;AACA,QAAA,IAAO;AACLsD,QAAAA;AACAjC,QAAAA;AAIE,WAAA,EAAA,IAAA,KAAA,QAAA;AACF,YAAA,KAAA,CAAA;AAEA,cAAA,QAAA,KAAA,GAAA;AACA,UAAIA,MAAMpB,UAAU,SAAQ;AAC1B,gBAAA,OAAA,GAAA;AAEAD;MACF;AAEH,UAAA,MAAA,UAAA,YAAA,UAAA,KAAA,KAAA,CAAA,SAAA,KAAA,GAAA;AAGCA,gBAAQ8D,OAAUC,GAAAA;MACpB;IAEA;EACF;;AChIA,YAAA,UAAA,YAAA,QAAA,SAAA,eAAA;EACA;AAEA,SAAA;;;AA6BI,SAAA,kBAAsBC,WAAQ;SAE1B,aAAU;QACZ,QAAUV,IAAK;AACjB,aAAA,QAAA;IAEA;AACD,UAAA,MAAA,UAAA,OAAA;AACH,QAAA,OAAA,QAAA,YAAA,OAAA,QAAA,UAAA;AAEaW,aAAAA,GAAAA,GAAAA;IAA2CC;AAASC,WAAG,GAAAC,GAAA,GAAA,CAAA;EAAExE;;AAAgBc,IAAAA,sBAAAA,kBAAAA,CAAAA;EAAM;EAC1F;EACA;;EAEA;AACE,MAAA;AAEF,MAAA,YAAA,QAAA;AAEA,cAAY2D,QAAAA,QAAW,eAAA,EAAA;SAClB;AAEH,cAAA;EACAF;AACF,MAAA,QAAA,QAAA;AAEA,UAAIvE,IAAM,QAAKyE,eAAW,EAAA;EACxBzE,OAAAA;AAEA,UAAA;EACAA;AACF,MAAA,WAAA,QAAA;AAEA,aAAO,OAAA,YAAA;EACLuE,OAAKD;AAELtE,aAAQA;EACRc;SACD;IACF,KAAA,WAAA,WAAA,MAAA,MAAA,MAAA;;IChED;;;;AAqBE,SAAA,WAAA,OAAA,UAAA,CAAA,GAAA;AAEA4D,MAAAA,cAAW1G,eAAkB2G,uBAAyB,uBAAmB,uBAAA,uBAAA,mBAAA;AAEzED,QAAAA,aAAkB;AAElB,MAAI,WAAWA,SAAAA,OAAWtE;AACxB,UAAM,IAAIwE,MAAM,yCAA8B;EAChD;AAEAF,aAAWlE,WAAUqE,OAAQrE,WAAW,cAAS,WAAA;AAEjDkE,aAAWI,UAAAA,QAAcD,WAAQC,mBAAeT;AAEhDK,MAAAA,CAAAA,UAAWK,WAAAA,OAAoBF,GAAAA;AAE/BH,UAAAA,IAAWM,MAAAA,6BACDA;EAEVN;AAGAA,aAAWO,UAAQJ,QAAQI,WAAS,oBAAA,IAASC;AAE7C,aAAA,cAAA,QAAA,eAAA;AACAR,aAAW7E,oBAAiB,QAAA,qBAAA;AAC1BmC,aAAQ6C,qBAAoB,QAAA,sBAAA,0BAAA,UAAA;AAE5BtC,aAAG4C,sBAAU5C,QAAG4C,uBAAI,2BAAa,UAAA;AAEjC,aAAA,QAAA,QAAA,SAAA,SAAA,OAAA;EAAA;aAESN,SAAQ5E,QAAO;IAExBmF,QAAAA,QAAgBP,UAAQO,CAAAA;IACtB,MAAA,eAAA,QAAA,QAAA,OAAA,eAAA,MAAA,KAAA;;;IAIFnG,SAAIoG,QAAAA,WAAER,CAAAA,OAAY,MAAA;IAElB,gBAAA,QAAA,kBAAA;;MAEA1F,aAAamG,YAAAA,CAAAA,KAAAA,KAAAA,KAAET,KAAAA,KAAQ1F,KAAAA,KAAa,KAAAmG,KAAAA,GAAAA,EAAAA,SAAAA,MAAAA;IAEpCjD;IAEAkD,OAAAA,gBAAaC,QAAAA,SAAEX,OAAO,gBAAc;;;IAMpC9D,gBAAO0E,wBAAU1E,QAAO,kBAAA0E,OAAA,wBAAIhB,QAAAA,SAAAA;IAC7B,kBAAA,wBAAA,QAAA,oBAAA,OAAA,wBAAA;IAED,gBAAA,wBAAA,QAAA,kBAAA,OAAA,wBAAA;IACAC,eAAWgB,wBACThB,QAAWM,iBAAmBtF,OAAAA,wBACnBsF;IAEbN,WAAWgB,oBAAsBC,QAC/BjB,aAAWkB,OAAAA,oBACXlB;IAGF,UAAOA,mBAAU,QAAA,YAAA,OAAA,mBAAA;EACnB;ACjGA,aAAA,aAAA,QAAA,IAAA,WAAA,mBAAA,aAAA,WAAA,mBAAA,UAAA;;;;AAyBUtE,SAAAA,gBAAQyF,SAAe,SAAA,gBAAA;AACzB,SAAA,aAAA;IACF,OAAA,MAAA;AACD,iBAAA,OAAA,SAAA;AAEG,YAAGnC,IAAG,WAAI,MAAA,GAAA;AACZ,kBAAU,WAAWoC,GAAAA;QACrB;MACD;IAEDnE;IACEvB,MAAAA,SAAQyF;AACT,YAAA,OAAA,QAAA,QAAA,SAAA,GAAA;AAEDpF,aAAS,OAAO,KAAI,MAAA,IAAA,IAAA;IAClB;YAEI,SAAA;cACF,WAAa,SAAA,GAAA;;SAEb,CAAA,KAAMsF,UAAS;AAMf,YAAA,OAAA,MAAA,QAAA,QAAA,SAAA,KAAA,KAAA,UAAA,KAAA,CAAA;AACA,UAAA;eACMtE,KAAK;MACPrB,SAAAA,OAAQyF;AACV,cAAA,YAAA,OAAA,QAAA,OAAA,EAAA,OAAA,UAAA,KAAA,CAAA,EAAA,WAAA,MAAA,CAAA,EAAA,IAAA,UAAA,CAAA,KAAA,CAAA,GAAA,KAAA,MAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AAGF,mBAAA,UAAA,WAAA;AACA,cAAI,OAAA,CAAA,EAAA,UAAA,YAAA,UAAA,OAAA,CAAA,CAAA,KAAA,CAAA,SAAA,OAAA,CAAA,CAAA,GAAA;AACF,oBAAOG,WAAM,OAAA,CAAA,CAAA;UACb;QACA;AAGA,YAAA;AAIA,iBAAK,KAAMC;QACT7F,SAAAA,SAAQyF;gBAIN,cAAA,UAAM,KAAA,CAAAK,IAAA,OAAAA,GAAA,CAAA,EAAA,aAAA,MAAA,EAAA,CAAA,EAAA,aAAA,EAAA;AACN,qBAAA,QAAA,aAAA;AAAA,oBAAA,WAAA,KAAA,CAAA,CAAA;AAEJ,gBAAA;AACF,qBAAA,KAAA;YAEA,SAAA,UAAA;YAEF;UACF;QACA;;;;;;",
  "names": ["cacheControlSymbol", "Symbol", "e", "r", "t", "a", "isDuration", "val", "Number", "Infinity", "isTruthy", "number", "parse", "headerStr", "header", "Object", "defineProperty", "enumerable", "value", "headers", "_step", "_iterator", "toLowerCase", "replace", "split", "done", "_split$", "maxAge", "maxStale", "minFresh", "sMaxAge", "staleIfError", "staleWhileRevalidate", "immutable", "mustRevalidate", "mustUnderstand", "noCache", "noStore", "noTransform", "onlyIfCached", "proxyRevalidate", "fastDeferSymbol", "Symbol", "deferred", "resolve", "reject", "promise", "Promise", "res", "rej", "sortNumbers", "a", "b", "hash", "val", "seen", "h", "toString", "Object", "prototype", "Array", "WeakSet", "keys", "sort", "i", "length", "key", "value", "has", "add", "constructor", "toHash", "Date", "getTime", "String", "error", "assign", "charCodeAt", "headers", "cc", "noCache", "noStore", "location", "immutable", "cache", "age", "Number", "expires", "predicate", "responseMatch", "containsHeaders", "statusCheck", "_response$headers$hea", "configUrl", "matchPattern", "requestMethod", "methodList", "some", "config", "etag", "_cache$data", "modifiedSince", "Header", "response", "previousCache", "status", "statusText", "defaultRequestInterceptor", "onFulfilled", "_extends", "axios", "defaults", "matched", "isMethodIn", "method", "methods", "overrideCache", "override", "storage", "state", "def", "deferred", "waiting", "set", "createdAt", "updateStaleRequest", "validateStatus", "createValidateStatus", "data", "hydrate", "cachedResponse", "transformResponse", "cached", "stale", "id", "cacheKey", "updater", "Object", "cacheUpdater", "value", "newValue", "remove", "defaultResponseInterceptor", "reject", "_response$cached", "cacheConfig", "update", "updateCache", "get", "header", "XAxiosCacheEtag", "interpretHeader", "expirationTime", "ttl", "staleTtl", "createCacheResponse", "XAxiosCacheStaleIfError", "String", "newCache", "delete", "onRejected", "error", "rejectResponse", "staleIfError", "staleHeader", "parse", "cacheControl", "resolve", "isStorage", "mustRevalidate", "isExpired", "canStale", "key", "length", "maxEntries", "keys", "shift", "find", "cloneData", "clear", "cleaner", "setInterval", "request", "defaultKeyGenerator", "baseURL", "url", "r", "undefined", "axiosCache", "window", "Error", "options", "generateKey", "headerInterpreter", "requestInterceptor", "debug", "noop", "_options$ttl", "cachePredicate", "_options$etag", "_options$modifiedSinc", "cacheTakeover", "_options$cacheTakeove", "_options$hydrate", "interceptors", "use", "responseInterceptor", "removeItem", "getItem", "allValues", "save", "item", "a"]
}
